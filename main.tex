\documentclass[12pt,twoside]{report}

% some definitions for the title page
\newcommand{\reporttitle}{Session-Typed Programming with Nested Protocols in Go}
\newcommand{\reportauthor}{Benito Echarren Serrano}
\newcommand{\supervisor}{Prof. Nobuko Yoshida}
\newcommand{\secondmarker}{Dr. Iain Phillips}
\newcommand{\reporttype}{Final Report}
\newcommand{\degreetype}{MEng Computing} 

\newcommand{\comment}[1]{}
\newcommand{\white}{\ \ \ \ \ \ \ \ \ \ \ \ }
\newcommand{\pad}{\ \ \ \ \ \ }
% load some definitions and default packages
\input{includes}

% load some macros
\input{notation}

% load title page
\begin{document}
\input{titlepage}
\setcitestyle{square}


% page numbering etc.
\pagenumbering{roman}
\clearpage{\pagestyle{empty}\cleardoublepage}
\setcounter{page}{1}
\pagestyle{fancy}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{abstract}
% Your abstract.
% \end{abstract}

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Acknowledgments}
% Comment this out if not needed.

% \clearpage{\pagestyle{empty}\cleardoublepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%--- table of contents
\fancyhead[RE,LO]{\sffamily {Table of Contents}}
\tableofcontents 


\clearpage{\pagestyle{empty}\cleardoublepage}
\pagenumbering{arabic}
\setcounter{page}{1}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
From the multiple cores in a CPU or GPU to the large server clusters in data centers, concurrency and parallelism have become an inherent part of computers and how they are used. This distributed computation model gives much higher performance and scalability, as multiple tasks can be executed at the same time, but it also makes reasoning about the software much harder, giving rise to concurrency bugs such as race conditions and deadlocks.\\

In order to reason about these concurrent and parallel programs, researchers have come up with different memory models with different guarantees. The two most important ones are shared memory and message passing. Shared memory is an abstraction where all the components can read and write to a single piece of memory, and the changes that anyone makes become visible to the other participants. On the other hand, message passing expresses the communications between different components as a series of message exchanges, with each process having its own address space. %However reasoning about it can be tricky, as some compiler and hardware optimisations reorder the instructions, and when different threads read and write to the same location in memory, race conditions can occur.
\\

When writing a concurrent program, understanding the concurrency model that you are using is vital to writing correct code. However, unlike the type system which provides some correctness guarantees about the program at compile time (type safety of assignments, method calls, etc.), programming languages generally offer little to no support when it comes to statically detecting concurrency bugs (deadlocks, race conditions, etc.). Although separate tools for different programming languages have been developed to do this, like FindBugs\cite{FindBugs} or Jlint\cite{JLint} for Java\comment{How Good is Static Analysis at Finding Concurrency Bugs?/Find Bugs paper and chord paper}, they do not scale well with the size of the program and may not find all the concurrency bugs in the implementation\cite{ConcurrencyTools}. Session types\cite{binarysessiontypes1} provide an alternative approach for reasoning about inter-process communication in a message passing setting. They formalise the structured interactions between the participants as a protocol, ensuring that there are no communication errors or concurrency bugs in the program. Instead of trying to find bugs in an existing implementation, session types guarantee that the implementation will be free of concurrency bugs. Unlike data types, which express the type of information that will be stored in memory during execution, session types describe the communication exchanges between processes.\\

% On the other hand, in message passing the components communicate by exchanging data in the form of explicit messages. This model can be used to express the communication between different components in a distributed system. The interactions of different participants exchanging typed data following a protocol can be formalized using session types \comment{ref session types}, which guarantee that communication errors such as deadlocks or receiving unexpected messages will not happen.
Session types have been extended in different directions in order to be more expressive by providing more control over the interactions through means such as logical assertions\cite{logicaassertions}. The theory has also been extended to allow greater flexibility on how participants can join or leave a session\cite{multirolesessiontypes} or having a parametric number of participants acting a particular role (e.g. n workers)\cite{parametrictypes}.\\

However, modern protocols have grown and become more complex. Often, they will have a highly modular structure, with a protocol calling or depending on other protocols. Moreover, different protocols may also share some common structure, with interactions between different participants following the same pattern. For instance, a protocol where a client wants to communicate with a server might initially involve authenticating with a different authentication server in order to get a valid token. This set of interactions with the authentication server could be considered a different subprotocol, which might also be used by many different applications in their authentication process. \\

Demangeon et al.\cite{nestedprotocols} extended the existing session type theory in order to allow nesting of protocols using subsessions and invitations. This new theory allows structuring such protocols in a more intuitive way and even provides the ability to be able to reuse subprotocols for different use cases. They also allow multiple calls to the same protocol with potentially different parameters, making the protocols more concise and readable. Subprotocols can also invite new participants to participate in them, which allows defining protocols with a dynamic number of participants. We develop the first implementation of this theory to give a session type-based framework for the specification and safe implementation of distributed programs in Go.\\

Existing session type-based frameworks required the number of participants to fixed at the start of the session. However, in nested protocols participants can be introduced into the session dynamically. Go can handle this kind of task very well by using two of its in-built primitives for concurrency\cite{godocs}: the ability to spawn thousands of lightweight threads called \textit{goroutines} and \textit{channels}, which allow inter-process communication through message passing. Dynamically delegating tasks by spawning new goroutines is common practice in Go, so this programming model is highly suitable for implementing nested protocols.

%The toolchain generates an implementation of the different roles in the protocol, allowing the user to define logic through callbacks. 
% \begin{figure}[tb]
% \centering
% \includegraphics[width = 0.4\hsize]{./figures/imperial}
% \caption{Imperial College Logo. It is nice blue, and the font is quite stylish. But you can choose a different one if you do not like it.}
% \label{fig:logo}
% \end{figure}

% Figure~\ref{fig:logo} is an example of a figure. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

\section{Session Types}
\subsection{Overview}

The two main models to reason about concurrent programs are shared memory and message passing. In shared memory, components communicate by reading and writing to a shared part of memory. This is how CPU threads and processes in a computer communicate with each other. However, reasoning about concurrent programs with this model can be tricky, as compiler and hardware optimisations can reorder the program's instructions\cite{sharedmemory}. On the other hand, in message passing inter-process communication is carried out by exchanging data in the form of explicit messages. This model closely resembles how communication is carried out in distributed systems.\\

Message passing can be encoded using the $\pi$-calculus, a process algebra based on name passing which was developed by Milner\cite{milnerpicalc}. In this calculus, processes communicate by sending channel names over named channels. We present an asynchronous variant of the $\pi$-calculus in section \ref{pi-calculus}. Session types\cite{binarysessiontypes1} introduce a typing discipline for formalising the communication exchanges between processes in the $\pi$-calculus. The initial theory was defined only for two participants, but it was later extended by Honda et al.\cite{asyncmpst1, asyncmpst2} to include multiple parties. This allowed the session types to encode a larger number of protocols. Session types improve the reliability of distributed systems by guaranteeing the correctness of the programs. If the processes are well-typed, they will have session fidelity and will not suffer from communication errors such as deadlocks, type mismatches or protocol violations.\\

There are already multiple implementations of session types for popular programming languages such as Java\cite{java}, C\cite{mpstc}, Go\cite{parametrictypes}, Python\cite{python}, Erlang\cite{erlang}, etc. Due to the set of features available to different programming languages, the implementation of MPST varies from one language to another. Some languages use rely on the type system to verify the correctness of the session's implementation at compile-time, while others may require run-time checks in order to detect protocol violations. 

\subsection{Asynchronous $\pi$-Calculus}\label{pi-calculus}
The $\pi$-calculus is a process algebra for encoding communicating systems. Processes communicate with one another through name passing, by sending and receiving channel names over named channels. The $\pi$-calculus is a simple yet powerful model which has been shown to be Turing-complete\cite{turingcomplete}, as it can encode the $\lambda$-calculus. The original theory was proposed by Robin Milner\cite{milnerpicalc}, but different variants have been proposed since. The first asynchronous $\pi$-calculus theory was presented in \cite{asyncandpicalc}, and we present a variant based on this theory, as defined in \cite{co406}.

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rrlcr}
        P,\ Q & ::= && \white & Processes \\[2.75pt]
             &   & 0 & \white & Nil\ Process  \\[2.75pt]
             & | & P\ |\ Q & \white & Parallel\ Composition \\[2.75pt]
             & | & (\nu\ a)\ P & \white & Scope Restriction \\[2.75pt]
             & | & !P & \white  & Replication \\[2.75pt]
             & | & \overline{u}\langle v \rangle & \white & Output \\[2.75pt] 
             & | & u(x).P & \white & Input \\\\
        u,\ v & ::= && \white & Identifiers \\[2.75pt]
              &   & a,\ b,\ c & \white & Names \\[2.75pt]
              & | & x,\ y,\ z & \white & Variables \\
        \end{array}
    \end{equation*}
    \caption{Syntax of monadic asynchronous  $\pi$-calculus}
    \label{picalc_syntax}
\end{figure}{}

The syntax of the asynchronous $\pi$-calculus is defined in Figure \ref{picalc_syntax}:
\begin{itemize}
    \item $0$ is the nil process, which represents the process with no actions.
    \item $P\ |\ Q$ is the parallel composition of two processes. These processes can execute in any order.
    \item $(\nu\ a)\ P$ is the scope restriction operation. It creates a new named channel $a$ that can only be used within process P and will not interfere with any other existing names.
    \item $!P$ is process replication. It represents the infinite parallel composition of process $P$: $P\ |\ P\ |\ P\ |\ ...$
    \item $\overline{u}\langle v \rangle$ is the output operation, which sends $v$ over $u$.
    \item $u(x).P$ is the input operation. It receives a a value over channel $u$. After receiving the value  it will continue executing process P, replacing all references to $x$ in $P$ with the received value.
\end{itemize}

Structural congruence is an equivalence relation which expresses that two processes are equivalent/interchangeable. We define the structural congruence of asynchronous $\pi$-calculus relation in Figure \ref{picalc_cong}.\\

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rcrclcr}
         & & P & \equiv & P & & Reflexivity\\[2.75pt]
         P \equiv Q & \implies & Q &\equiv\ & P & & Symmetry  \\[2.75pt]
         P \equiv Q\ \land\ Q \equiv R & \implies & P & \equiv & R & & Transitivity \\[2.75pt]
         P \equiv Q\ & \implies & (\nu\ a)\ P & \equiv & (\nu\ a)\ Q & & Cong\ of\ Restriction \\[2.75pt]
         P \equiv Q\ & \implies & P\ |\ R & \equiv & Q\ |\ R & & Cong\ of\ Parallel\ Comp \\[2.75pt]
         P \equiv Q & \implies & u(x).P & \equiv & u(x).Q & & Cong\ of\ Input \\[2.75pt]
         P \equiv Q & \implies & !P & \equiv & !Q & & Cong\ of\ Replication \\[2.75pt]
         P\ =_\alpha \ Q\ & \implies & P & \equiv & Q &  & \alpha-equivalence \\[2.75pt]
         & & P\ |\ (Q\ |\ R) & \equiv & (P\ |\ Q)\ |\ R & & Associativity \\[2.75pt]
         & & P\ |\ Q & \equiv & Q\ |\ P & & Commutativity \\[2.75pt]
         & & P\ |\ 0 & \equiv & P & & Zero \\[2.75pt]
         & & !P & \equiv & P\ |\ !P & & Replication \\[2.75pt]
         & & (\nu\ a)\ 0 & \equiv & 0 & & Res\ of\ Nil \\[2.75pt]
         & & (\nu\ a)(\nu\ b)\ P\ & \equiv & (\nu\ b)(\nu\ a)\ P & & Res\ of\ Restriction \\[2.75pt]
         a\ \notin\ fn(P) & \implies & \ P\ |\ (\nu\ a)\ Q & \equiv & (\nu\ a)(P\ |\ Q) & & Res\ over\ Parallel\ Comp
        \end{array}
    \end{equation*}
    \caption{Structural congruence of monadic asynchronous  $\pi$-calculus}
    \label{picalc_cong}
\end{figure}{}

The operational semantics of the $\pi$-calculus shown in Figure \ref{picalc_op_sem} define how the communication between the processes happens. The most important rule is \textsc{Comm}, which shows how the value sent by the output process is received by the input process and used in its continuation $P$ by replacing the references to the variable $x$ in $P$.

\begin{figure}[h!]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{c}
    \inference{}{\overline{a}\langle v \rangle\ |\ a(x).P\ \longrightarrow\ P\{\sfrac{v}{x}\}}[\textsc{Comm}]\\[20pt]
    \inference{P\ \longrightarrow\ P'}{P\ |\ Q\ \longrightarrow\ P'\ |\ Q}[\textsc{Par}]\\[20pt]
    \inference{P\ \longrightarrow\ P'}{(\nu\ a)\ P \longrightarrow\ (\nu\ a)\ P'}[\textsc{Res}]\\[20pt]
    \inference{
        P \equiv Q 
        & Q\ \longrightarrow\ Q' 
        & Q' \equiv P'
    }{P\ \longrightarrow\ P'}[\textsc{Struct}]
    \end{array}
    \end{equation*}
    \caption{Operational semantics of monadic asynchronous $\pi$-calculus}
    \label{picalc_op_sem}
\end{figure}{}

It is important to notice that the output process $\bar{u} \langle v \rangle$ does not have any continuation. This reflects the asynchronous nature of the calculus. However, the asynchronous pi calculus presented above is very expressive; it is possible to encode other variants of $\pi$-calculus using it, including synchronous $\pi$-calculus, which allows continuation after output, and polyadic $\pi$-calculus, which allows exchanging vectors of messages at once. 

% The intuition for encoding synchronous $\pi$-calculus is to use two additional channels to agree on a rendez-vous between the sender and the receiver. The sender will send a channel over which to communicate, and the receiver will send a private channel over which the exchange will actually take place. To encode polyadic synchronous $\pi$-calculus using monadic synchronous pi cal, 

% \begin{table}[]
%     \centering
%     \begin{tabular}{l|p{6cm}|p{6cm}}
%          &$monadic\ asynchronous\ \longrightarrow\ monadic \ synchronous$ & $mondadic\ synchronous\ \longrightarrow\ polyadic\ synchronous$ \\
%          \hline
%          \textsc{Input} & $\llbracket \bar{u} \langle v \rangle.P$\rrbracket = \hfill (\nu\ c)(\bar{u} \langle c \rangle\ |\ c(y).(\bar{y} \langle v\rangle\ |\ \llbracket P \rrbracket))& $\llbracket \bar{u} \langle v \rangle.P$\rrbracket = \hfill (\nu\ c)(\bar{u} \langle c \rangle\ |\ c(y).(\bar{y} \langle v\rangle\ |\ \llbracket P \rrbracket))
         
%     \end{tabular}
%     \caption{Caption}
%     \label{tab:my_label}
% \end{table}{}

\subsection{Binary Session Types}
A session is a unit of conversation between participants. Session types provide a structured way to define and reason about the communications which take place between participants. In binary session types, these interactions happen between two participants. A session results from the binary composition of the processes of each participant. There are multiple similar formulations for session types in the literature, but Figure \ref{bst_session_calc} shows the syntax for processes in binary session types as presented in \cite{co406}. %presented in \textit{the CO406 course}\comment{replace with reference}.\\

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rrlcr}
        v & ::= & \underline{n} & \white & Integers \\[2.75pt]
              & |  & \texttt{true}\ |\ \texttt{false} & \white & Booleans \\[2.75pt]
              & | & \texttt{"str"} & \white & Strings \\\\
        e,\ e' & ::= & v & \white & Values \\[2.75pt]
              & |  & x & \white & Variables \\[2.75pt]
              & | & e\ +\ e'\ |\ e\ -\ e'\ |\ -e & \white & Arithmetic \\[2.75pt]
              & | & e\ =\ e'\ |\ e\ <\ e'\ |\ e\ >\ e' & \white & Relational \\[2.75pt]
              & | & e\ \land\ e'\ |\ e\ \lor\ e'\ |\ \lnot e & \white & Logical \\
              & | & e\ \bigoplus\ e' & \white & Non-determinism\\\\
        
        
        p & ::= & Alice\ |\ Bob & \white & Participant\\\\
        P,\ Q & ::= && \white & Processes \\[2.75pt]
             &   & 0 & \white & Nil\ Process  \\[2.75pt]
             & | & \overline{p} \langle e \rangle.P & \white & Output \\[2.75pt] 
             & | & p(x).P & \white & Input\\[2.75pt]
             & | & p\ \triangleright\ \{l_i:\ P_i\}_{i\in I}& \white & Branching\\[2.75pt]
             & | & p\ \triangleleft\ l.P& \white & Selection \\[2.75pt]
             & | & \texttt{if}\ e\ \texttt{then}\ P\ \texttt{else}\ Q & \white & Conditional \\[2.75pt]
             & | & \mu X.P & \white  & Recursive\ Process \\[2.75pt]
             & | & X & \white  & Recursive\ Variable \\\\
             
        M & ::= & p :: P\ |\ q :: Q & \white & Binary\ Composition
        \end{array}
    \end{equation*}
    \caption{Processes in the binary session calculus}
    \label{bst_session_calc}
\end{figure}{}

\begin{itemize}
    \item $0$ is the nil process, which represents no actions.
    \item $\overline{p} \langle e \rangle.P$ is the output operation, which sends the value $e$ to participant $p$ with continuation $P$ (the session calculus is synchronous).
    \item $p(x).P$ is the input operation, which waits for participant $p$ to send a value $x$. Upon receiving the value, execution continues with $P$, with the received value replacing the references to $x$ in $P$.
    
    \item $p\ \triangleright\ \{l_i:\ P_i\}_{i\in I}$ is the branching operation. The process waits for participant $p$ to send a label $l\ =\ l_i$, for some $i \in I$. After receiving the label, execution continues with process $P_i$.
    
    \item $p\ \triangleleft\ l.P$ is the selection operation. The process sends label $l$ to participant $p$, then continues executing $P$.
    
    \item $\texttt{if}\ e\ \texttt{then}\ P\ \texttt{else}\ Q$ is the conditional operation. Expression $e$ should evaluate to a boolean. If $e$ evaluates to true then process $P$ is executed, otherwise, $Q$ is executed.
    
    \item $\mu X.P$ and $X$ are used to express recursion in the processes. The recursive process $\mu X.P \equiv P\{\sfrac{\mu X.P}{X}\}$, that is, you are able to replace all the instances of the recursion variable $X$ in P with $\mu X.P$. This allows you to carry out potentially infinite unfoldings of the process.
    
    \item $e\ \bigoplus\ e'$ expresses a non-deterministic choice between two expressions of the same type, so the expression could evaluate to the result of either of the two expressions. 
    
    \item The evaluation of expressions is only defined when the types match: logical expressions are only defined on expressions which evaluate to booleans, arithmetic expressions and $e\ <\ e'$ and $e\ >\ e'$ are only defined on integer values, and $e\ =\ e'$ is only defined if $e$ and $e'$ have the same type.
\end{itemize}{}

This session calculus is based on the $\pi$-calculus, so we can observe a great amount of similarities between the constructs in both calculi. The main differences are the introduction of the branching and selection operations (which can be encoded in the $\pi$-calculus), the definition of recursion and the conditional process. \\

% The operational semantics for a session $M\ =\ p::P\ |\ q::Q$ are defined in a similar manner to the $\pi$-calculus. Additional rules are required for the branching/selection and the conditional processes. Reducing a recursive process may involve unfolding the recursion multiple times through structural congruence. For a formal definition please\\

We introduce the definition of the session types in Figure \ref{bst_session_types}. We will not give the formal typing judgements for the processes, these can be found in \cite{co406, binarysessiontypes1, subtyping}\comment{Course material ref and possibly language primitives}. However, we give an intuition behind the correspondence between processes and their session types:

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rrlcr}
        S & ::= && \white & Session\ Type \\[2.75pt]
             &   & \texttt{end} & \white & Termination  \\[2.75pt]
             & | & p![U];\ S & \white & Value\ Send \\[2.75pt]
             & | & p?[U];\ S & \white & Value\ Receive \\[2.75pt]
             & | & p \bigoplus \{l_i\ :\ S_i\}_{i \in I} & \white& Selection \\[2.75pt]
             & | & p \& \{l_i\ :\ S_i\}_{i \in I} & \white & Branching \\[2.75pt] 
             & | & t & \white & Type\ Variable \\[2.75pt]
             & | & \mu t.S & \white & Recursive\ Type\\\\
        U & ::= & \texttt{int}\ |\ \texttt{bool}\ |\ \texttt{string}& \white & Sorts\ for\ Expressions
        \end{array}
    \end{equation*}
    \caption{Syntax of binary session types}
    \label{bst_session_types}
\end{figure}{}

\begin{itemize}
    \item $Bob(x).\overline{Bob} \langle x + 1 \rangle.0:\ Bob?[\texttt{int}];\ Bob![\texttt{int}];\ \texttt{end}$ - In order to infer the sort of the input variable it may be necessary to see how it is used in the process.
    \item $Alice\ \triangleleft\ choice.\overline{Alice} \langle \texttt{"hello"} \rangle.0:\ Alice \bigoplus \{choice:\ Alice![\texttt{str}];\ \texttt{end}\}$ - similarly for branching.
    \item In order to be able to specify a type for a conditional process $\texttt{if}\ e\ \texttt{then}\ P\ \texttt{else}\ Q$, both branches $P$ and $Q$ must have the same type $S$, and therefore the type of the conditional process will also $S$.
    \item $\mu t.S$ and $t$ are used to specify recursive types. They work much in the same way as recursive processes; recursive types can also unfolded by replacing instances of $t$ in $S$ by $\mu t.S$.
\end{itemize} 

\begin{figure}[h!]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rcl}
             \overline{\texttt{end}} & = & \texttt{end}  \\[2.75pt]
             \overline{p![U];\ S} & = & p?[U];\ \overline{S} \\[2.75pt]
             \overline{p?[U];\ S} & = & p![U];\ \overline{S} \\[2.75pt]
             \overline{p \bigoplus \{l_i\ :\ S_i\}_{i \in I}} & = & p \& \{l_i\ :\ \overline{S_i}\}_{i \in I}\\[2.75pt]
             \overline{p \& \{l_i\ :\ S_i\}_{i \in I}} & = & p \bigoplus \{l_i\ :\ \overline{S_i}\}_{i \in I}\\[2.75pt]
             \overline{\mu t.S} & = & \mu t.\overline{S}\\[2.75pt]
             \overline{t} & = & t
        \end{array}
    \end{equation*}
    \caption{Duality of binary session types}
    \label{bst_duality}
\end{figure}{}

A key concept in binary session types is duality. When two processes are composed in a session, in order for the session to progress correctly, both processes must be carrying out complimentary operations. For instance, if $Alice$ is trying to send a string to $Bob$, $Bob$ must be waiting to receive a string from $Alice$, otherwise the protocol is stuck. Similarly, if $Bob$ is waiting for a label from $Alice$ to decide which branch to execute, $Alice$'s process must send one of the expected labels. Not only must the constructs be complimentary, but the types of the messages being sent must also match. Therefore, in order for a session to be correct, the processes involved must be duals of one another. This will ensure that the binary session will always make progress and that the session continues to be well-typed as the protocol is carried out. The duality of binary session types is shown in Figure \ref{bst_duality}.



\subsection{Multiparty Session Types}\label{multiparty-session-types}
Binary session types have limited applications to real-world problems, as standard protocols tend to be much more complex and involve more than two participants. These interactions cannot always be correctly expressed as the composition of binary sessions between different pairs of participants. \\

Multiparty session types\cite{asyncmpst2} extend the theory by allowing protocols to have multiple participants, thus overcoming these limitations. The main idea is to introduce global types, which describe the multiparty interactions within a protocol from a global perspective, as well as deriving a specification of the behaviour of each participant as local session type through the projection operation. \\

There are multiple variants of processes and their respective MPST in the literature. We present the syntax for synchronous multiparty session types defined in \cite{verygentleintrotompst} in Figure \ref{MPST_processes}.

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rrlcr}
        P,\ Q & ::= && \white & Processes \\[2.75pt]
             &   & 0 & \white & Nil\ Process  \\[2.75pt]
             
             & | & \texttt{if}\ e\ \texttt{then}\ P\ \texttt{else}\ Q & \white & Conditional \\[2.75pt]
             & | & \mu X.P & \white  & Recursive\ Process \\[2.75pt]
             & | & X & \white  & Recursive\ Variable\\[2.75pt]
             & | & p!l \langle e \rangle.P & \white & Output \\[2.75pt]
             & | & \sum\limits_{i \in I} p?l_i(x_i).P_i & \white & Branching \\\\

        M & ::= &&& Multiparty\ Session\\[2.75pt]
        & | & p :: P\ & \white & Process\\[2.75pt]
        & | & M\ |\ M\ & \white & Parallel\ Composition\\\\
        
        &&p,\ q,\ r,\ ... & \white & Participants\\[2.75pt]
        &&e,\ e',\ ... & \white & Expressions\\[2.75pt]
        &&x,\ y,\ z,\ ... & \white & Expression\  variables
        \end{array}
    \end{equation*}
    \caption{Processes in multiparty session calculus}
    \label{MPST_processes}
\end{figure}{}

Although the syntax varies slightly from the one showed in Figure \ref{bst_session_calc}, the semantics are essentially the same. The main difference is that processes now send/receive a label with the value they communicate. Because sessions now involve multiple participants, it is necessary to specify the other participant for the exchange (it would have been possible to omit this information in binary session types). \\

In multiparty session types, when deriving the types for protocols we consider both the global type, which formally specifies the interactions between all the participants in the protocol from a global perspective and local session types, which characterize the interactions that each of the participants carry out within the global protocol. The parallel composition of processes satisfying the session types implements the behaviour of the global type. In this way, the implementations of the different participants are decoupled from one another, so they could be implemented separately and the overall implementation would be correct as long as they all follow their respective session types.

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rrlcr}
        S & ::= & \texttt{int}\ |\ \texttt{bool}\ |\ \texttt{string}& \white & Sorts\\\\
        \textsc{Global\ Types} & && &\\[3pt]
        G & ::= & \texttt{end} & \white & Termination  \\[2.75pt]
             & | & p \longrightarrow q: \{l_i( S_i).G_i\}_{i \in I} & \white & Branching \\[2.75pt] 
             & | & t & \white & Type\ Variable \\[2.75pt]
             & | & \mu t.G & \white & Recursive\ Type\\\\
             
        \textsc{Local Types} &&&& \\[3pt]
        T & ::= & \texttt{end} & \white & Termination  \\[2.75pt]
          & | & \bigoplus_{i \in I}\ p!l_i(S_i).T_i & \white& Selection \\[2.75pt]
          & | & \&_{i \in I}\ p?l_i(S_i).T_i & \white & Branching \\[2.75pt] 
          & | & t & \white & Type\ Variable \\[2.75pt]
          & | & \mu t.S & \white & Recursive\ Type
        
        \end{array}
    \end{equation*}
    \caption{Syntax of multiparty session types}
    \label{MPST_types}
\end{figure}{}

We present the syntax for global and local types in Figure \ref{MPST_types}. Similarly to the syntax of processes, the local session types are almost the same as the binary session types. Global types introduce a single construct for branching/selection, $p \longrightarrow q:\{l_i(S_i).G_i\}_{i \in I}$, in which participant $p$ sends to $q$ the label (and corresponding value) which will determine what the continuation is.\\

Each participant in the protocol enacts a role in the global type. The session type for each role is derived by projecting the global type onto that role, which essentially ignores all the interactions in which the role does not take part, leaving only the behaviour that needs to be implemented for that role within the protocol. The projection operation is defined in Figure \ref{MPST_projection}.\\

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rcl}
        
        (p \longrightarrow p':\{l_i(S_i).G_i\}_{i \in I}) \upharpoonright q & = &
        \begin{cases}
            \bigoplus_{i \in I}\ p'!l_i(S_i).(G_i \upharpoonright q) & \text{if}\ q\ =\ p\\
            \&_{i \in I}\ p?l_i(S_i).(G_i \upharpoonright q) & \text{if}\ q\ =\ p'\\
            G_{i_0} \upharpoonright q & \text{where}\ i_0 \in I,\ \text{if}\ q \notin \{p,\ p'\}\\
            & \text{and}\ \forall i,j \in I.\ G_i \upharpoonright q\ =\ G_j \upharpoonright q
        \end{cases}\\[33pt]
        (\mu t.G) \upharpoonright q & = & 
        \begin{cases}
            \mu t.(G \upharpoonright q) & \text{if}\ G \upharpoonright q \neq t\\
            \texttt{end} & otherwise
        \end{cases}\\[13pt]
        t \upharpoonright q & = & t\\[2.75pt]
        \texttt{end} \upharpoonright q & = & \texttt{end}\\[2.75pt]
        \end{array}
    \end{equation*}
    \caption{Projection of Global Types to Local Types}
    \label{MPST_projection}
\end{figure}{}

Projecting a role $q$ on $\texttt{end}$ and $t$ (type variable) has no impact, since $q$ is not participating in any exchange. When projecting on $p \longrightarrow p':\{l_i(S_i).G_i\}_{i \in I}$, depending on which role $q$ is undertaking in the exchange, the projected session type will change. 
\begin{itemize}
    \item If the $q = p$, then the projection is a selection, as the process decides which label and value to send to $p'$. The continuations $G_i$ must be projected onto $q$ as well.
    \item Similarly, if $q = p'$, $q$ will be waiting for a message from $p$, therefore the projected session type is a branching operation. 
    \item  When $q$ does not participate in the label exchange, the projection becomes more tricky. There are multiple approaches to resolve this situation; the one shown in Figure \ref{MPST_projection} is known as plain merge. Since $q$ does not know which branch will have been chosen by $p$, all branches must have the same continuation from $q$'s viewpoint, otherwise $q$ would not know which behaviour to implement. A different approach called the full merge allows a less restrictive definition\cite{verygentleintrotompst}.
    
\end{itemize}

In binary session types, ensuring that both participants implemented session types which were duals of one another was enough to guarantee the correctness of the protocol. With multiple participants however, that is not the case anymore. Although you can ensure that each pair of participants has dual interactions, in order to guarantee the correctness that alone is not enough. The projection operation allows the composition to the different local types to satisfy the global type. Multiparty session types can therefore provide many guarantees about the communication well-typed multiparty sessions such as:
\begin{itemize}
    \item \textbf{Progress}: A multiparty session $M$ can either have ended ($M\ \equiv\ p :: 0$) or it can continue to execute (there exists $M'$ such that $M \longrightarrow M'$). This means that every sent message will eventually be received and every process waiting for a message eventually receives one. \cite{verygentleintrotompst, gentleintrotompst}
    \item \textbf{Subject reduction}: If a well-typed session $M:\ G$ reduces to $M'$, then $M':\ G'$ is well typed\cite{verygentleintrotompst}.
    \item \textbf{Type Safety}: If $M:\ G$ is well-typed then the session will never get stuck - a session where there are processes which have not finished must able to continue executing\cite{verygentleintrotompst}.
    \item \textbf{Protocol fidelity}: All interactions which happen are expressed in the global type of the protocol\cite{gentleintrotompst}.
    \item \textbf{Communication Safety}: There can never be a mismatch between the types of messages which are sent and which are expected\cite{gentleintrotompst}.
\end{itemize}{}

\subsection{Scribble API Endpoint Generation}\label{Scribble}
Scribble\cite{scribble,featherweight} is a protocol description language based on multiparty session types. The Scribble framework translates this formal definition of the protocol into an implementation in one of various programming languages, thus allowing the theory of MPST to be used in a practical setting. A protocol describes the structure of the message exchanges between different roles, the entities which will participate in the protocol.\\

We present the syntax of the Scribble language as defined in the Featherweight Scribble paper\cite{featherweight} in Figure \ref{scribble-global-protocol}. A Scribble module can contain multiple protocols, with one of them being the designated point of entry for the computation. Protocols can call each other through the $\scrdo$ construct, but this essentially corresponds to inlining the called protocol. In order for a protocol call to be valid, it must be called with number of roles specified in its declaration. The remaining syntactic constructs relate very closely to the different session types in the theory, described in Section \ref{multiparty-session-types}. A message exchange is specified by the label of the message and the type of its payload, \texttt{S}, and the sender and receiver roles. Although here we only specify one payload type there could potentially be zero or more multiple ones. The $\choice$ construct encodes the external choice by a role, with a set of the different continuations which can happen based on the role's choice. The recursive type and type variables are directly encoded by the $\rec$ and $\continue\ t$ constructs, and the \texttt{end} session type is represented with the $\scrend$ construct.\\



\begin{figure}[!h]
    \centering
    \begin{math}
        \begin{array}{rcl}
            \mathit{Module} & ::= & \mathit{P}+\\\\
            \mathit{P} & ::= & \scrglobal\ \protocol\ \mathit{pro}(\rolessig{A}{n})\ \{\;\mathit{G}\;\} \\\\
            % G & ::= & \texttt{end} & \white &
            \mathit{G} & ::= &\\[2.75pt]
              &   | & \choice\ \at\ \mathit{A}\ \{\;\mathit{G_1}\;\}\ \scror\ ...\ \scror\ \{\;\mathit{G_n}\;\} \\[2.75pt]
              &   | & \scrmessage{a}{S}\ \from\ \mathit{A}\ \scrto\ \mathit{B};\ \mathit{G} \\[2.75pt]
              &   | & \rec\ \mathit{t}\ \{\;G\;\} \\[2.75pt]
              &   | &  \continue\ \mathit{t} \\[2.75pt]
              &   | & \scrdo\ \mathit{pro}(\roles{A}{n});\ \mathit{G} \\[2.75pt]
              &   | & \scrend \\[2.75pt]
        \end{array}
    \end{math}
    \caption{Syntax of Scribble global protocols}
    \label{scribble-global-protocol}
\end{figure}

A syntactically correct protocol where all the protocol calls are valid can be expanded with the interactions of the called protocols to produce a single large protocol with all the interactions which must be performed. Scribble the verifies that the protocol is well-formed, which means that local protocols can be generated for all the roles. Syntactically correct protocols can be ambiguous, for instance, if the first message in two branches of a $\choice$ have the same signature, as other roles would not be able to tell which branch has been chosen. The local protocols are derived by projecting the global type onto each of the roles. A communication finite state machine (CFSM) is then generated for each of the local protocols, which expresses the valid transitions between states that a role can carry out during the protocol. These transitions represent a message exchange with a different participant.\\

An example of a global protocol can be seen in Figure \ref{scribble_protocol}, which shows a calculator protocol carried out by two roles: a client who enters the operands and the server who carries out the operation. The protocol has a recursive loop in which the client can choose to either send two numbers to multiply to the server, get the result back and start over again or quit the protocol. The resulting CFSM for the server $S$ can be seen in Figure \ref{scribble_fsm}.\\

\begin{figure}[h]
    \centering
    \lstset{language=Scribble}
    \begin{lstlisting}
global protocol Calc(role S , role C ) {
    rec Loop {
    	choice at C {
    		multiply(int, int) from C to S;
    		result(int) from S to C ;
    		continue Loop ;
    	} or {
    		quit() from C to S ;
    		terminate() from S to C ;
    	}
    }
}
    \end{lstlisting}
    \caption{Calculator Protocol}
    \label{scribble_protocol}
\end{figure}{}

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.53]{scribble_fsm.png}
    \caption{CFSM for role S in Calculator Protocol}
    \label{scribble_fsm}
\end{figure}{}
We describe how the CFSMs can be used to generate code in an OOP programming language like Java for the different endpoints (roles) in the protocol. Each of the states in the CFSM is converted to a class with methods for each of the outgoing transitions from the current state, which carry out the necessary communication operations and return the next state. The user can chain calls to these methods to carry out the protocol, transitioning only between valid states until the final state is reached, which does not have any outgoing transitions. \\

In order to ensure the correctness of the implementation, every state must only be used once, which may require run-time checks. Implementations using the Scribble-generated APIs benefit from the correctness guarantees of MPST, ensuring that there are no communication errors and that the protocol is followed properly.\\

\section{Nested Protocols}
\subsection{Motivations}
The theory of session types has been extended in different directions in order to be able to become more expressive. Some advances have made it possible to annotate the protocol with logical assertions to define extra properties that the protocol should meet\cite{logicaassertions}. Other developments have made it possible to express protocols with parametrised roles\cite{parametrictypes} (expressing protocols where $n$ participants carry out particular roles), or to have greater control over how participants can join or leave a session through a dynamic multiparty session\cite{multirolesessiontypes}. \\

Demangeon et al.\cite{nestedprotocols} try to address a different challenge: protocols used in networking and in distributed systems are increasingly large. In many cases, they are highly modular, and often different protocols share the same structure. In order to better define and manage these protocols they extend the theory of session types to include nested protocols, which make it possible to define complex protocols using a simpler modular structure. Using this approach, protocols which have a similar structure can be grouped together under a single parametrised protocol, and complex protocols which might call other protocols can be expressed by making a call to those subprotocols. Moreover, different calls to the same subprotocol can be made with different parameters to achieve different behaviours. Their theory also allows subprotocols to bring in new participants by `inviting' them to participate. This can help simplify some protocols, as it allows you specify protocols where participants are brought in/contacted only if required.

\subsection{Session Calculus}
The theory they proposed is based on the idea of nesting protocols, where a parent protocol may define independent subprotocols and call them during its execution. Calls to a protocol can pass in different kinds of arguments as parameters such as values, roles from the parent protocol which will participate in the subprotocol and even other protocols which might be used during the call, similar to higher-order functions in functional programming.\\ 

Subprotocols are implemented as subsessions. The participant calling the protocol will create a new private session for its execution, and will send \textit{internal invitations} to all the roles in the parent protocol which will participate, and \textit{external invitations} to bring in new agents. In this way, only the roles which have a access to the subsession, so the other roles in the parent session will not be able to interfere with it. This model thus allows private interactions in a public session. The Scribble language described in Section \ref{Scribble} also allows subprotocols. However, as opposed to this theory, the roles participating in Scribble protocols have to be known statically, meaning that a call corresponds to inlining the subprotocol.\\

Calling subprotocols also abstract away their actual implementation, which means that the implementation of the subprotocol can be changed (e.g. to change how authentication is carried out or to improve the protocol's security) without changing the implementation of the parent protocol. Subprotocols also give a better separation between the different execution branches of the protocol, as different external participants can be invited only when required, reducing the complexity and utilisation of resources. For instance, in an HTTP-like protocol a proxy could have the choice of either returning a cached response directly or to initiate a \textit{Contact} protocol to involve the server and get the response. \\

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rrlcr}
        P,\ Q & ::= && \white & Processes \\[2.75pt]
             &   & 0 & \white & Nil\ Process  \\[2.75pt]
             & | & P\ |\ Q & \white & Parallel\ Composition  \\[2.75pt]
             & | & a(x).P & \white & Receive\ Ext.\ Invitation \\[2.75pt]
             & | & \overline{a}\langle s \rangle.P & \white & Send\ Ext.\ Invitation \\[2.75pt]
             & | & P\ +\ P & \white & Non-determinism\\[2.75pt]
             & | & k?[r, r]_{i \in I} \{l_i(x_i).P_i\}& \white & Branching \\[2.75pt]
             & | & k![r, r]l \langle v \rangle.P & \white & Selection \\[2.75pt]
             & | & (\nu\ u)\ P & \white & Scope\ Restriction\\[2.75pt] 
             & | & \texttt{new}\ s\ \texttt{on}\ k\ \texttt{with}\ (\widetilde{v})\&(\widetilde{a}\ \texttt{as}\ \widetilde{r}).P & \white & Subprotocol\ Call\\[2.75pt]
             & | & s \downarrow [r,\ r_1 : r_2](x).P & \white & Receive\ Internal\ Invitation\\[2.75pt]
             & | & s \uparrow [r,\ r_1 : r_2]\langle s \rangle.P & \white & Send\ Internal\ Invitation\\[2.75pt]
             & | & \mu X(x).P\langle v \rangle & \white  & Recursive\ Process \\[2.75pt]
             & | & X\langle v \rangle & \white  & Recursive\ Variable\\\\

        % M & ::= &&& Multiparty\ Session\\[2.75pt]
        % & | & p :: P\ & \white & Process\\[2.75pt]
        % & | & M\ |\ M\ & \white & Parallel\ Composition\\\\
        &&s,\ k,\ ... & \white & Session\ names\\[2.75pt]
        &&a,\ b,\ u,\ ... & \white & Shared\ channels\\[2.75pt]
        &&v & \white & Values\\
        &&r,\ r',\ ... & \white & Role\ Identifiers\\[2.75pt]
        &&x,\ y,\ z,\ ... & \white & Variables
        \end{array}
    \end{equation*}
    \caption{Processes in Session Calculus for Nested Protocols}
    \label{nested_session_calculus}
\end{figure}{}

Figure \ref{nested_session_calculus} shows the session calculus presented in the paper which includes the syntax for invitations and defining protocols. The calculus is based on the $pi$-calculus and shares a lot of the constructs of other existing session calculi\cite{logicaassertions}. Names are divided into two kinds: session channels, which handle all exchanges within a session, and shared channels, used to send and receive external invitations. 
\begin{itemize}
    \item Parallel composition, scope restriction and the nil process are defined as before.
    \item Recursion is also defined in a similar way as before, but it allows passing in a value to the recursive call which may be used when the recursive call is expanded. 
    \item $a(x).P$ and $\overline{a}\langle s \rangle.P$ are used for receiving and sending external invitations over the shared channel $a$.
    \item $P\ +\ P$ is the non-deterministic process. Execution can continue with either one of the two processes.
    \item $k?[r_1, r_2]_{i \in I} \{l_i(x_i).P_i\}$ is the branching operation from $r_1$ to $r_2$ with continuation $P_i$ in session $k$. $k![r_1, r_2]l \langle v \rangle.P$ is the selection operation, its dual primitive. 
    \item $s \downarrow [r,\ r_1 : r_2](x).P$ is the action for waiting for an internal invitation sent by $r$ to $r_1$ in order to play role $r_2$ in session $s$. 
    \item $s \uparrow [r,\ r_1 : r_2]\langle s \rangle.P$ is the action of sending an invitation from $r$ to $r_1$ in order to play role $r_2$ in session $s$.
    \item $\texttt{new}\ s\ \texttt{on}\ k\ \texttt{with}\ (\widetilde{v})\&(\widetilde{a}\ \texttt{as}\ \widetilde{r}).P$ is the operation for calling a subprotocol. Creates a new subsession $s$ within the parent session $k$, passing in arguments $\widetilde{v}$ and using shared channels $\widetilde{a}$ to send the external invitations.
\end{itemize}

\subsection{Session Types}\label{nested-session-types}
The paper also extends the syntax of session types to include the types for defining and calling subprotocols as well as sending and receiving invitations. The extended syntax for local and global types is shown in Figure \ref{nested_session_types}. They define kinds (types for types), including $\diamond$, which represents the protocol type, in order to formalize the definition of protocols. The definition of global types is essentially the same as before:
\begin{itemize}
    \item Termination, branching and recursion are almost the same as before. They also define the type for parallel composition.
    \item They introduce the construct $G_1\ \bigoplus^r\ G_2$ to represent located choice, where role $r$ can choose between two different branches. 
    \item $\texttt{let}\ \mathcal{P}\ =\ \lambda\widetilde{r}^1,\ \widetilde{y} \mapsto \texttt{new}\ \widetilde{r}^2.G\ \texttt{in}\ G'$ defines a subprotocol $\mathcal{P}$. The vector of roles $\widetilde{r}^1$ defines a set of roles that will be carried out by roles from the parent protocol which will be internally invited, whereas the vector $\widetilde{r}^2$ contains the set of roles which will be externally invited. The protocol also takes in vector of values $\widetilde{y}$.
    \item $r\ \texttt{calls}\ \mathcal{P}\langle \widetilde{r},\ \widetilde{y}\rangle.G$ is the subprotocol call carried out by role $r$, internally inviting roles $\widetilde{r}$ and passing in the values $\widetilde{y}$.
\end{itemize}{}

Similarly, the local session types are also very similar with the exception of the new constructs to handle invitations and protocol calls:
\begin{itemize}
    \item Termination, branching, selection and recursion are almost unchanged, and they introduce a type for parallel composition. 
    \item The construct $T_1\ \bigoplus^r\ T_2$ represents located choice.
    \item $\texttt{call}\ \mathcal{P}:G\ \texttt{with}\ (\widetilde{v}\ \texttt{as}\ \widetilde{y}:\widetilde{S})\&(\widetilde{r}^2).T$ is a call to the subprotocol $\mathcal{P}$, which has global type $G$, sending a vector of values $\widetilde{v}$ as arguments with sorts $\widetilde{S}$ and externally inviting the roles in $\widetilde{r}^2$ to participate in the subprotocol.
    \item Sending and accepting invitations for a role $r$ are handled by the $\texttt{req}\ \mathcal{P}[r]\langle \widetilde{v} \rangle\ \texttt{to}\ r.T$ and $\texttt{ent}\ \mathcal{P}[r]\langle \widetilde{v} \rangle\ \texttt{from}\ r.T$ constructors respectively.
\end{itemize}{}

\begin{figure}[h]
    \centering
    \begin{equation*}
    \centering
    \begin{array}{rrlr}
        Val & ::= & \texttt{int}\ |\ \texttt{bool}\ |\ \texttt{string} & Sorts\\\\
        K, S & ::= & Role\ |\ Val\ |\ \diamond\ |\ (K_1\ \times\ ...\ \times\ K_n) \longrightarrow K & Kinds\\\\
        
        \textsc{Global\ Types} & & &\\[3pt]
        G & ::= & \texttt{end} & Termination  \\[2.75pt]
             & | & \texttt{let}\ \mathcal{P}\ =\ \lambda\widetilde{r}^1,\ \widetilde{y} \mapsto \texttt{new}\ \widetilde{r}^2.G\ \texttt{in}\ G' & Subprotocol\ Def\\[2.75pt]
             & | & r\ \texttt{calls}\ \mathcal{P}\langle \widetilde{r},\ \widetilde{y}\rangle.G  & Subprotocol\ Call \\[2.75pt]
             & | & r_1 \longrightarrow r_2: \sum_{i \in I}\{l_i( S_i).G_i\} &  Branching \\[2.75pt]
             & | & G_1\ \bigoplus^r\ G_2   & Located Choice \\[2.75pt]
             & | & G_1\ |\ G_2 & Parallel\ Composition \\[2.75pt]
             & | & t & Type\ Variable \\[2.75pt]
             & | & \mu t.G & Recursive\ Type\\\\
             
        \textsc{Local Types} &&& \\[3pt]
        T & ::= & \texttt{end} &  Termination  \\[2.75pt]
          & | & \texttt{send}[r]!_{i \in I}\{ l_i(x_i: S_i).T_i\} & Selection \\[2.75pt]
          & | & \texttt{get}[r]?_{i \in I}\{l_i(x_i:S_i).T_i\} &  Branching \\[2.75pt] 
          & | & T_1\ \bigoplus \ T_2   & Located Choice \\[2.75pt]
          & | & T_1\ |\ T_2 & Parallel\ Composition \\[2.75pt]
          & | & \texttt{call}\ \mathcal{P}:G\ \texttt{with}\ (\widetilde{v}\ \texttt{as}\ \widetilde{y}:\widetilde{S})\&(\widetilde{r}^2).T &  Subprotocol Call \\[2.75pt]
          & | & \texttt{ent}\ \mathcal{P}[r]\langle \widetilde{v} \rangle\ \texttt{from}\ r.T &  Accept Invitation \\[2.75pt]
          & | & \texttt{req}\ \mathcal{P}[r]\langle \widetilde{v} \rangle\ \texttt{to}\ r.T &  Send Invitation \\[2.75pt]
          & | & t &  Type\ Variable \\[2.75pt]
          & | & \mu t.T &  Recursive\ Type
        
        \end{array}
    \end{equation*}
    \caption{Syntax of Session Types for Nested Protocols}
    \label{nested_session_types}
\end{figure}{}

As before, deriving the local types from the global type is done through the projection operation. It works very much in the same way as before, although now it becomes necessary to define a protocol environment to hold the types of the nested protocols, which gets updated by the $let\ in$ constructor.\\ 

Figure \ref{nested_session_projection} shows the definition of projection for the nested protocol definition and call. Projection on the remaining constructors is defined in the standard way. Projection of a protocol definition updates the environment with the protocol's global type and signature and continues recursively projecting the type. When projecting a nested protocol call onto a role $r^p$, there are multiple cases to consider:
\begin{itemize}
    \item if $r^p$ is the caller but does not participate itself in the subprotocol, the projection must only send out the internal invitations in parallel, as well as executing the projection of the continuation.
    \item if $r^p$ is the caller as well as a participant, then it must also send all the internal invitations to all the participating roles, but that includes itself, it must also accept its own invitation.
    \item if $r^p$ did not call the protocol but is a participant of the protocol, then it must simply accept the invitation, with the continuation being the projection of the continuation of the global type.
    \item otherwise, $r^p$ is neither a participant or the caller, so the projection is the projection of the continuation of the global type.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{nested_session_projection.png}
    \caption{Projection of Global Type in Nested Protocols\cite{nestedprotocols}}
    \label{nested_session_projection}
\end{figure}{}

\subsection{Returning Values from Subprotocols}\label{nested-protocols-return-value}
One limitation of the formulation expressed above is the inability of communication from a subsession back to the parent subsession. This means that it is impossible to express in a session type the relationship between a value calculated during a subsession and a value which a role might send after the nested protocol has ended. \\

For example, in the Client-Proxy-Server protocol described in Figure \ref{nested_session_example}, the value the server returns is $ans$, but that value cannot be seen outside of the $Contact$ subprotocol, so the proxy (middle) can only return $ans_0$ after completing the call to $Contact$. However, there are no guarantees that these two values are the same. The paper proposes some further extensions to the syntax of session types in order to make the protocol end by returning a value to the role which initiated the call in order to be able to capture be able to return information from the subprotocol. \\

Nevertheless, the current theory will suffice in most scenarios, as the kinds of the messages alone restrict what values can be sent, and it is up to the user's implementation to decide which value to send. Any value which satisfies this constraint can be considered a valid implementation of the protocol.
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{nested_session_example.png}
    \caption{Example of Global Session Type for CPS Protocol\cite{nestedprotocols}\comment{nested protocols snippet}}
    \label{nested_session_example}
\end{figure}{}

% \subsection{Code Generation in Golang}
% Gois a popular industrial systems language.1One of its primary design features is first-classlanguage support for lightweight concurrency on multicore machines. Go offers easy spawningof parallel coroutines, calledgoroutines, that are transparently multiplexed over an underlyingset of system threads. Goroutines communicate and synchronize via message passing over typedchannels, designed to alleviate the difficulties of low-level mechanisms such as mutexes, conditionvariables and memory barriers commonly used in systems programming. As first-class objects, aninteresting andusefulfeature is the ability to passchannels over channels.Go is also well-established in distributed systems; e.g., it is the implementation language offrameworks such as Kubernetes, Docker and Jaeger. As the aforementioned concurrency features ofGo are specific to shared memory, a significant class of distributed programming in Go is conductedusing channel-based networking libraries via TCP, HTTP, etc. as transports. Developers appreciateGo since distributed programming in practice often involves local concurrency: goroutines andchannels are effective for dealing locally with the inherent asynchrony of distributed interactions
% For this project, the aim is to be able to generate a correct implementation of a protocol which uses nested protocols given a MPST-based specification. The target language for the framework to be developed is Go. Go is a popular programming language in industry. It has already been used to develop large projects like Docker and Kubernetes, and one of the reasons for its popularity is that it has inbuilt concurrency mechanisms. It has light-weight 

% In order for a global type to be well-formed, it must be projectable and well-kinded. Informally, well-kind which informally means that a mapping from all the identifiers in the global type to kinds can be found which 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Extending Scribble with Nested Protocols}\label{scribble-extensions-chapter}
% TODO: Verify this after extending Scribble background
In this chapter we present a version of the Scribble protocol language as presented in \cite{scribble}. We extend the syntax of both global and local types with contructs for representing nested protocols similar to the ones described the in the original paper\cite{nestedprotocols}. We introduce a precise definition of a protocol's scope - the protocols which are able to call a protocol, and extend the definition of well-formedness to take our syntax extensions into account. Finally, we extend the projection of Scribble global protocols with the new constructs we introduce.



\section{Syntax Extensions}\label{scribble-extensions}

% Scribble already allows defining multiple protocols in one module and protocols calling each other. However, in order to represent nested protocols, we need to extend Scribble with the ability to define protocols inside other protocols. Moreover, in the current implementation, protocol calls essentially correspond to inlining the interactions of the called protocol, but, as described in Section \ref{nested-session-types}, nested protocol calls involve inviting participating roles, external participants into the subsession and accepting the invitations before carrying out the interactions of the called protocol. Therefore, we will extend the Scribble syntax with suitable constructs for these operations and incorporate the semantics of nested protocol calls into the framework.\\

In Section \ref{Scribble} we described how the Scribble syntax already has most of the constructs needed to encode session types, including constructs for encoding labeled message exchanges, recursion and external choice. However, the session types pesented in the nested sessions paper\cite{nestedprotocols}, which we describe in Section \ref{nested-session-types}, also include some constructs which are not currently implemented in Scribble, like the internal choice session type. We have decided to focus on implementing the main functionality related to nested protocols, such as allowing the declaration of protocols inside other protocols and introducing the use of invitations in order to participate in a nested protocol call, rather than extending Scribble with other non-essential constructs. We will therefore not support internal choice, but this should not be a great limitation, as the external choice construct will suffice for most use cases.
\\

The definition of nested protocols presented in the nested protocols paper\cite{nestedprotocols}, which can be seen in Section \ref{nested-session-types}, allowed a nested protocol call to specify values which should be passed into the subsession. We will not support the ability to send values when calling a nested protocol explicitly. However, in the protocol implementation we will provide a means for the user to pass in values to subsessions by initialising the state of the different roles which will participate in the nested protocol, so this omission should not have a great impact in practice.\\

We introduce a precise definition for the scope of protocols, which the original paper did not handle explicitly. Through the use of scopes, the users can encapsulate different behaviours as nested protocols which can only be used inside a protocol, and these scope restrictions will be verified by the framework.\\

\subsection{Global Protocols}\label{scr-global-protocols}

We have extended the definition of a Scribble module, which we described in Section \ref{Scribble}, with nested protocols. Previously, a module was a collection of global protocols, but now it can also contain zero or more top-level nested protocols. However, it must still contain at least one global protocol (with no dynamic roles), which can be used as the entry point for the computation. Like in the original paper\cite{nestedprotocols}, nested protocols can also be defined inside both nested and global protocols.\\

Although nested protocols could in theory be defined anywhere within a scope, for ease of parsing in the Scribble implementation and to provide more structured Scribble modules, we restrict the location where nested protocol can be declared. At the top-level, any nested protocols must be defined before the global protocol declarations, and within other protocols, they must be declared before any of the interactions. However, these restrictions do not impact the expressiveness of the implementation, as the order of the protocol declarations within a scope does not matter.\\

\begin{figure}[!h]
    \begin{center}
        \begin{tabular}{l}
            % \begin{math}
            %     \begin{array}{@{}rcl}
            %         \mathit{Module} & ::= & \mathit{N}\!*\ \mathit{P}+\\[7.5pt]
            %         \mathit{PBody} & ::= & \mathit{N}\!*\ \mathit{G}
            %     \end{array}
            % \end{math}\\[18pt]
            $\mathit{Module}\ ::=\ \mathit{N}\!*\ \mathit{P}+$\\[8pt]

            $\mathit{PBody}\ ::=\  \mathit{N}\!*\ \mathit{G}$\\[8pt]

            $\mathit{N}\ ::=\ \nested\ \protocol\ \mathit{pro}(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{\;\mathit{PBody}\;\}$\\[8pt]
            
            \begin{math}
                \begin{array}{@{}rcl}
                    \mathit{P} & ::= & \scrglobal\ \protocol\ \mathit{pro}(\rolessig{A}{n})\ \{\;\mathit{PBody}\;\}\\[5pt]
                    \mathit{G} & ::= &\\[2.75pt]
                        &   | & \choice\ \at\ \mathit{A}\ \{\;\mathit{G_1}\;\}\ \scror\ ...\ \scror\ \{\;\mathit{G_n}\;\} \\[2.75pt]
                        &   | & \scrmessage{a}{S}\ \from\ \mathit{A}\ \scrto\ \mathit{B};\ \mathit{G} \\[2.75pt]
                        &   | & \rec\ \mathit{t}\ \{\;G\;\} \\[2.75pt]
                        &   | &  \continue\ \mathit{t} \\[2.75pt]
                        &   | & \scrdo\ \mathit{pro}(\roles{A}{n});\ \mathit{G} \\[2.75pt]
                        &   | &  \mathit{A}\ \calls\ \mathit{pro}(\roles{A}{n});\ G\\[2.75pt]
                        &   | & \scrend \\[2.75pt]
                \end{array}
            \end{math}
        \end{tabular}
    \end{center}
    % $\mathit{Module}\ ::=\ \mathit{N}\!*\ \mathit{P}+$\\[8pt]

    % $\mathit{PBody}\ ::=\  \mathit{N}\!*\ \mathit{G}$\\[8pt]

    % $\mathit{N}\ ::=\ \nested\ \protocol\ \mathit{pro}(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{\;\mathit{PBody}\;\}$\\[8pt]

    % $\mathit{P}\ ::=\ \scrglobal\ \protocol\ \mathit{pro}(\rolessig{A}{n})\ \{\;\mathit{PBody}\;\}$\\[8pt]

    % \begin{center}$
    %     \begin{array}{rcl}
    %         \mathit{G} & ::= &\\[2.75pt]
    %             &   | & \choice\ \at\ \mathit{A}\ \{\;\mathit{G_1}\;\}\ \scror\ ...\ \scror\ \{\;\mathit{G_n}\;\} \\[2.75pt]
    %             &   | & \scrmessage{a}{S}\ \from\ \mathit{A}\ \scrto\ \mathit{B};\ \mathit{G} \\[2.75pt]
    %             &   | & \rec\ \mathit{t}\ \{\;G\;\} \\[2.75pt]
    %             &   | &  \continue\ \mathit{t} \\[2.75pt]
    %             &   | & \scrdo\ \mathit{pro}(\roles{A}{n});\ \mathit{G} \\[2.75pt]
    %             &   | &  \mathit{A}\ \calls\ \mathit{pro}(\roles{A}{n});\ G\\[2.75pt]
    %             &   | & \scrend \\[2.75pt]
    %     \end{array}
    % $\end{center}
    % }
    \caption{Syntax for Scribble module with nested protocols}
    \label{scribble-nested-syntax-global}
\end{figure}

% \begin{figure}[!h]
%     \begin{itemize}
%         \item $\mathit{Module}\ ::=\ \mathit{N}\!*\ \mathit{P}+$
%         \item $\mathit{N}\ ::=\ \nested\ \protocol\ \mathit{pro}(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{\;\mathit{PBody}\;\}$
%         \item  $\mathit{P}\ ::=\ \scrglobal\ \protocol\ \mathit{pro}(\rolessig{A}{n})\ \{\;\mathit{PBody}\;\}$
%         \item $\mathit{PBody}\ ::=\  \mathit{N}\!*\ \mathit{G}$
%         \item $\mathit{G}\ ::= $
        
%         $\quad\quad|\ \choice\ \at\ \mathit{A}\ \{\;\mathit{G_1}\;\}\ \scror\ ...\ \scror\ \{\;\mathit{G_n}\;\}$
    
%         $\quad\quad|\ \scrmessage{a}{S}\ \from\ \mathit{A}\ \scrto\ \mathit{B};\ \mathit{G}$
        
%         $\quad\quad|\ \rec\ \mathit{t}\ \{\,\mathit{G}\;\}$
        
%         $\quad\quad|\ \continue\ \mathit{t}$
        
%         $\quad\quad|\ \scrdo\ \mathit{pro}(\roles{A}{n});\ G$
    
%         $\quad\quad|\ \mathit{A}\ \calls\ \mathit{pro}(\roles{A}{n});\ G$
        
%         $\quad\quad|\ \scrend$
    
%     \end{itemize}
%     \caption{Syntax for Scribble module with nested protocols}
%     \label{scribble-nested-syntax-global}
% \end{figure}


A formal specification of our proposed syntax for Scribble modules with nested protocols is given in Figure \ref{scribble-nested-syntax-global}, and we provide some examples of global and nested protocols in Figure \ref{scribble-nested-global}. We introduce several new keywords in order to define nested protocols and calls to nested protocols, while trying to preserve as much of the original syntax and behaviour as possible.
\begin{itemize}
    \item The $\nested$ keyword can be used to define protocols with dynamic participants. Dynamic participants are separated from regular participants by a $\scrnew$ keyword in the protocol declaration. However, nested protocols need not have dynamic participants, in which case the latter part of the declaration can be omitted. When a protocol is defined within another protocol, it restricts the scope where it can be used, much like defining a nested function in a programming language. We also allow shadowing of protocol names: if you redefine a protocol in an inner scope, then it will override the previous definition in that scope and all its subscopes.
    \item The $\calls$ construct introduces a subsession, where a role calls a nested protocol, inviting a set of roles to carry out the interactions of the nested protocol. In a $\calls$ construct the dynamic participants of the nested protocol are omitted - it is only necessary to specify which existing roles which be participating, as the remaining roles will be dynamically created.
    \item We modify the semantics of the $\scrdo$ construct, which previously resulted in expanding the interactions of the called protocol, to instead create a subsession. Its semantics are equivalent to a $\calls$ construct, where the first partipant in the protocol is treated as the caller. However, we restrict the use of the $\calls$ construct to only call nested protocols and the $\scrdo$ construct to call global protocols. 
    \item The distinction between global and nested protocols is important, and needs to be verified to ensure that any protocol call used the correct construct. Moreover, protocol calls need to be verified to ensure that the call matches the signature of the protocol which is in scope, as protocol declarations with the same protocol name in different scopes may involve a different number of participants.
    \item As before, the $\scrend$ construct can be omitted when writing down protocol declarations.
\end{itemize}

\begin{figure}[h]
    \centering
    \lstset{language=Scribble}
    \begin{lstlisting}
    
    nested protocol NestedProtocol(role X; new role Y) {
        do GlobalProtocol(X, Y);
    }
    
    global protocol GlobalProtocol(role A, role B) {
        B calls NestedProtocol(A);
    }
        \end{lstlisting}
        \caption{Scribble syntax for nested protocols}
        \label{scribble-nested-global}
    \end{figure}{}
 
\subsection{Scopes}

As it was briefly mentioned in Section \ref{scribble-extensions}, the original paper\cite{nestedprotocols} did not handle the scopes in which protocols could be called explicitly. In our Scribble extension we provide a more precise definition of protocol's scope and how it affects which protocols can be called from within different protocols in a Scribble module.\\

In a Scribble module we have the top-level scope, where the user can define global and nested protocols which can be called from any protocol, no matter how deeply nested its declaration is. As we mentioned in Section \ref{scr-global-protocols}, each protocol declaration introduces a new scope of its own.  Any nested protocols defined within are not visible outside that  protocol, but can be used in that protocol's implementation and any nested protocols defined within.\\

The main restriction we have applied is that within any given scope, there must never be a clash between protocols of the same kind. For simplicity, the naming conflicts only take into account the name of the protocol rather than the full signature. This means that global protocols, which can only be defined at the top level, must always have unique names, and no two nested protocols defined in the same scope can have the same name.\\

The distinction between the $\scrdo$ and $\calls$ constructs for calling global and nested protocols makes it possible to unambiguously define a nested protocol and a global protocol with the same name without one definition shadowing the other. However, in this case the user must be careful when calling the protocol, especially if they have signatures with the same number of non-dynamic participants, as it can be easy to confuse which protocol call was intended. If the signatures are different this should be less of a problem, as trying to call a protocol with the wrong number of participants will produce an error.\\

As we mentioned in Section \ref{scr-global-protocols}, defining a nested protocol with the same name as a nested protocol in an outer scope will override the definition in the current scope and any inner scopes. Global protocol definitions cannot be shadowed, as they can only be defined within the top-level scope. When checking that protocol calls are valid it is is important to keep track of the protocols which are currently in scope and their signatures to ensure that the call matches the number of roles in the protocol's signature. 

\subsection{Local Protocols}

After extending the syntax for Scribble global protocols we also had to modify the definition of projection of Scribble global types presented in \cite{featherweight} to include these new constructs, which we describe in Section \ref{scribble-projection}. We therefore extend the syntax of Scribble local types with constructs for sending and receiving invitations following the session types presented in \cite{nestedprotocols}. \\

% \begin{figure}[h!]
%     \begin{itemize}
%         \item $L ::=\scrlocal\ \protocol\ A@pro(\role A_1,\ ...,\ \role A_n;\ \scrnew\ \role\ B_1,\ ...,\ \role\ B_m)\ \{T\}$
%         \item $T ::= $
        
%         $\quad\quad|\ \choice\ \at\ A\ \{T_1\}\ \scror\ ...\ \scror\ \{T_n\}$
    
%         $\quad\quad|\ \scrmessage{a}{S}\ \from\ B;\ T$
    
%         $\quad\quad|\ \scrmessage{a}{S}\ \scrto\ B;\ T$
        
%         $\quad\quad|\ \rec\ t\ \{T\}$
        
%         $\quad\quad|\ \continue\ t$
        
%         $\quad\quad|\ \invite(A_1,\ ...\ ,\ A_n)\ \scrto\ pro;\ T$
        
%         $\quad\quad|\ \create(\role\ B_1,\ ...\ ,\role\ B_n)\ \scrin\ pro;\ T$
    
%         $\quad\quad|\ \accept\ C@pro(A_1,\ ...\ ,\ A_n;\ \scrnew\ B_1,\ ...\ ,\ B_m)\ \from\ A;\ T$
    
%         $\quad\quad|\ \scrend$
%     \end{itemize}
%     \caption{Syntax of Scribble local protocols extended with invitations}
%     \label{scr-local-protocols-syntax}
% \end{figure}

\begin{figure}[h!]
    \begin{center}
        \begin{tabular}{l}
            $\mathit{L}\ ::=\ \scrlocal\ \protocol\ \mathit{A@pro}(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{\;T\;\}$ \\\\
            \begin{math}
                \begin{array}{@{}rcl}
                    \mathit{RecvMsg} & ::= & \\[2.75pt]
                     & | & \messageFromL{a}{S}{B}\\[2.75pt]
                     & | & \acceptL{C@pro}{A}{B}{A}\\\\
        
                    \mathit{T} & ::= &\\[2.75pt]
                      &   | & \choice\ \at\ \mathit{A}\ \{T_1\}\ \scror\ ...\ \scror\ \{T_n\} \\[2.75pt]
                      &   | & \rec\ \mathit{t}\ \{\;T\;\} \\[2.75pt]
                      &   | &  \continue\ \mathit{t} \\[2.75pt]
                      &   | & \scrmessage{a}{S}\ \scrto\ \mathit{B};\ \mathit{T} \\[2.75pt]
                    %   &   | & \scrmessage{a}{S}\ \from\ \mathit{B};\ \mathit{T} \\[2.75pt]
                      &   | & \mathit{RecvMsg};\ \mathit{T}\\[2.75pt]
                      &   | & \invite(\roles{A}{n})\ \scrto\ \mathit{pro}\,;\ \mathit{T} \\[2.75pt]
                      &   | & \create(\rolessig{B}{m})\ \scrin\ \mathit{pro}\,;\ \mathit{T}\\[2.75pt]
                    %   &   | & \accept\ \mathit{C@pro}(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ \mathit{A}\,;\ \mathit{T}\\[2.75pt]
                    &   | & \scrend \\[2.75pt]
                \end{array}
            \end{math}
        \end{tabular}
    \end{center}
    \caption{Syntax of Scribble local protocols extended with invitations}
    \label{scr-local-protocols-syntax}
\end{figure}

% \begin{figure}[h!]
%     \centering
%     \begin{math}
%         \begin{array}{rcl}
%             \mathit{L} & ::= & \scrlocal\ \protocol\ \mathit{A@pro}(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{\;T\;\} \\\\
%             % G & ::= & \texttt{end} & \white &
            
%             \mathit{RecvMsg} & ::= & \\[2.75pt]
%              & | & \messageFromL{a}{S}{B}\\[2.75pt]
%              & | & \acceptL{C@pro}{A}{B}{A}\\\\

%             \mathit{T} & ::= &\\[2.75pt]
%               &   | & \choice\ \at\ \mathit{A}\ \{T_1\}\ \scror\ ...\ \scror\ \{T_n\} \\[2.75pt]
%               &   | & \scrmessage{a}{S}\ \from\ \mathit{B};\ \mathit{T} \\[2.75pt]
%               &   | & \scrmessage{a}{S}\ \scrto\ \mathit{B};\ \mathit{T} \\[2.75pt]
%               &   | & \rec\ \mathit{t}\ \{\;T\;\} \\[2.75pt]
%               &   | &  \continue\ \mathit{t} \\[2.75pt]
%               &   | & \invite(\roles{A}{n})\ \scrto\ \mathit{pro}\,;\ \mathit{T} \\[2.75pt]
%               &   | & \create(\rolessig{B}{m})\ \scrin\ \mathit{pro}\,;\ \mathit{T}\\[2.75pt]
%               &   | & \accept\ \mathit{C@pro}(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ \mathit{A}\,;\ \mathit{T}\\[2.75pt]
%               &   | & \scrend \\[2.75pt]
%         \end{array}
%     \end{math}
%     \caption{Syntax of Scribble local protocols extended with invitations}
%     \label{scr-local-protocols-syntax}
% \end{figure}

Our proposed extensions to the syntax of Scribble local protocols are shown in Figure \ref{scr-local-protocols-syntax}, and some examples of local protocols, which correspond to the projections of the protocols in Figure \ref{scribble-nested-global}, are can be seen in Figure \ref{scribble-nested-local}. We have kept all the original Scribble constructs and added three new ones for sending invitations, accepting invitations and for initializing dynamic roles:

\begin{itemize}
    \item The sending of internal invitations is expressed by the $\invite$ construct, which specifies the roles which are going to participate, and the name of the protocol to which they are invited. The syntax for the $\invite$ contruct shown above can be seen as a shorthand for sending a series of individual invitations in parallel (asynchronously) to all the roles who are going to participate in the protocol. Indeed, this idea could be expressed with an alternative notation such as:
    $\{\invite(A_i)\ \scrto\ pro;\}_{i \in \{1,\ ...\ ,\ n\}};\ T$

    \item Bringing new participants into the subsession through external invitations is done through the $\create$ statement, which specifies the dynamic roles of the protocol to be created. Similarly to the $\invite$ construct, the proposed syntax can be seen as a shorthand for the sending in parallel of external invitations.
    
    \item Internal invitations are accepted through the $\accept$ construct, which contains information about the participant which sent the inviation, the local protocol which the role is going to be carrying out as well as all the other roles which will be participating as well.
\end{itemize}

% TODO: verify projection
\begin{figure}[htb!]
    \centering
    \lstset{language=Scribble}
    \begin{lstlisting}
    
    local protocol X@NestedProtocol(role X; new role Y) {
        invite(X, Y) to GlobalProtocol;
        accept A@GlobalProtocol(X, Y);
    }

    local protocol Y@NestedProtocol(role X; new role Y) {
        accept B@GlobalProtocol(X, Y);
    }
    
    local protocol A@GlobalProtocol(role A, role B) {
        accept X@NestedProtocol(A; new Y) from B;
    }

    local protocol B@GlobalProtocol(role A, role B) {
        invite(A) to NestedProtocol;
        create(role Y) in NestedProtocol;
    }
    \end{lstlisting}
    \caption{Scribble syntax for nested protocols}
    \label{scribble-nested-local}
\end{figure}{}

\section{Well-formedness}
% When moving this, I need to ensure that I define what a valid protocol call is before it is refered to in other places.
In order to be able to generate the implementation of a protocol specified by the user, the Scribble framework must first verify that the protocol is well-formed.\\ Both the Featherweight Scribble \cite{featherweight} and the Nested Protocols\cite{nestedprotocols} papers share a similar definition for this property: in order for a protocol to be well-formed a protocol it must be projectable and all protocol calls must be valid. A protocol is projectable if the projection is defined for all the participants of that protocol, and a protocol call is valid if the called protocol is defined/in scope, it is called with the correct number of roles and all the roles involved are distinct and in scope (participating in the current protocol).\\

Despite our extensions to the Scribble framework, the well-formedness property remains the same. However, we highlight the importance of ensuring that protocol calls are valid after introducing nested scopes and the ability to shadow protocol declarations, allowing users to declare protocols with the same name and different declarations in different scopes. We also extend the definition of projection given in the original Nested Protocols paper\cite{nestedprotocols} by incorporating the full merge operator, which the original paper did not. In order to do this, we extend the definition of the merge operator defined in the Featherweight Scribble paper\cite{featherweight}.

% The well-formedness property for protocols still remains the same as before \cite{nestedprotocols}\cite{featherweight}. We say a protocol is well-formed if it is projectable and all protocol calls are valid. A protocol is projectable if the projection is defined for all the participants of that protocol. We incorporate the merging operator into the projection, which the original paper did not, extending the definition with the cases for invitations. A protocol call is valid if the protocol called is in scope, it is called with the correct number of roles and all the roles involved are distinct and in scope (participating in the current protocol).

\section{Renaming Protocols}\label{renaming}

The representation of Scribble nested protocols we have defined in Section \ref{scr-global-protocols} is very similar to the representation of nested protocols given in the original paper\cite{nestedprotocols}. However, the distinction between global and nested protocols and protocol calls in Scribble makes it slightly more complicated and verbose to define the projection of protocols, and name clashes between protocols in different scopes will need to be resolved at some point before code generation to be able to generate a correct implementation of the protocols.\\

In order to simplify the process, we propose introducing an extra preprocessing step on the protocols before projecting them, once the global and nested protocols have been validated to ensure they are syntactically correct and that all protocol calls are valid. The objective in this step is to generate a simpler, flattened representation of the Scribble module, where all the protocols are stored in a single set. In order to achieve this, name clashes need to be resolved to ensure that all protocol names are unique, and all references to the protocols in protocol calls must be renamed to the new unique names. Ensuring that all protocol names are globally unique has the added advantage of allowing us to remove the distinction between nested and global protocols and treat protocol calls to both global and nested protocols uniformly, as there can be no ambiguity with regards to which protocol is going to be called.\\

The result of this renaming process is a set of protocols which do not contain any nested protocols within, where both global and nested protocols have been converted into this intermediate representation. We define a slightly different syntax for this representation, as shown in Figure \ref{protocols-after-renaming}, which is essentially the same as a nested protocol declaration without any nested protocols inside.\\

\begin{figure}[h!]
    \centering
    $\protocol\ P(\role\ A_1,\ ...,\ \role\ A_n;\ \scrnew\ \role\ B_1,\ ...,\ \role\ B_m)\ \{\;G\;\}$\\
    \caption{Intermediate representation of protocols after renaming}
    \label{protocols-after-renaming}
\end{figure}

We present a renaming algorithm which uses two environments. The first one maps the original protocol names that were accessible in the current scope to the unique names of the protocols they refer to, while the second environment holds the set of all the unique protocol names which have been generated. The scope environment can be used to update the protocol calls in the interactions of a protocol, and the protocol name environment is necessary to generate globally unique protocol names. We define the algorithm in pseudocode in Figures \ref{renaming-interactions} and \ref{renaming-module}.\\

The first step in the algorithm is to aggregate the information from the protocol declarations in the top-level scope into both environments. When resolving clashes between top-level nested and global protocols we decided to always change the nested protocol names and keep the global protocol names without changing them. This approach allows us to only keep a single environment for the nested protocols which are in the current scope, as global protocol names will not change, so there is no need to track them in a separate environment. We add the unique names of both the top-level global and nested protocols to the protocol name environment, and store a mapping from the nested protocol names to their new unique names in the scope environment. As well as updating the environments, we also change the protocol names in the nested protocol declarations. This process can be seen in lines 15-25 of the \texttt{rename\_module} function in Figure \ref{renaming-module}.\\

Once we have all the information about the top-level scope, we can proceed to recursively rename the interactions of all the protocols, aggregating all the resulting protocols in a single set. In order to update the interactions of a protocol, we must first update both the scope and protocol name environments with the nested protocol declarations inside the current protocol. The procedure for how this can be done is shown in the function \texttt{rename\_nested\_protocols} in Figure \ref{renaming-interactions}. We first generate a new unique name for each of the protocols and add it to the protocol name environment. The scope environment is updated by creating/modifying the mapping for the protocol's old name so that it refers to the new name. We also update the declarations of the nested protocols with their new unique names here. Once both environments have been updated, we recursively rename the interactions of each of the nested protocols and store them in the result set. Finally, we update the protocol names in the current protocol's interactions using the scope environment and add the protocol with its new interactions to the result set.\\
 
The procedure we have just described is implemented in the \texttt{\seqsplit{rename\_and\_flatten\_protocols}} function in Figure \ref{renaming-module}. We need to return the updated protocol name environment as well as the set of renamed protocols to ensure that the protocol names we generate are unique. Otherwise, clashes could occur between protocols defined inside different nested protocols. However, the scope environment does not contain any useful information outside the current scope, so it can be ignored once the protocol's interactions have been updated. \\

Renaming a protocol's interactions simply requires recursively traversing the global type, as shown in the \texttt{rename\_protocol\_calls} function in Figure \ref{renaming-interactions}. The only interactions which change are the global protocol calls and nested protocol calls. In order to treat both types of calls in the same way, global protocol calls are converted explicitly to the $\calls$ construct with the first participant initiating the call. As global protocol names were not changed, the protocol name in the call remains the same. On the other hand, updating nested protocol calls requires looking up the unique protocol name corresponding to the protocol being called in the scope environment and building a new $\calls$ construct with it.\\

\begin{figure}[h!]
    \centering
    \lstset{language=Pseudocode}
    \begin{lstlisting}[escapeinside={(*}{*)}]
    def rename_protocol_calls(G, ScopeEnv):
        match G with:
            | A calls P((*$\roles{A}{n}$*)); (*$\mathtt{G_1}$*) ->
                newP = ScopeEnv[P]
                (*new$\mathtt{G_1}$*) = rename_protocol_calls((*$\mathtt{G_1}$*), ScopeEnv)
                return A calls newP((*$\roles{A}{n}$*)); (*new$\mathtt{G_1}$*)
            | do P((*$\roles{A}{n}$*)); (*$\mathtt{G_1}$*) -> 
                (*new$\mathtt{G_1}$*) = rename_protocol_calls((*$\mathtt{G_1}$*), ScopeEnv)
                return (*$\mathtt{A_1}$*) calls P((*$\roles{A}{n}$*)); (*new$\mathtt{G_1}$*)
            | choice at A (*$\mathtt{\{\;G_i\,\}_\varinset{i}{I}}$*) ->
                return choice at A (*$\mathtt{\{\;\;rename\_protocol\_calls(G_i,\ ScopeEnv)\;\;\}_\varinset{i}{I}}$*)
            | rec t (*$\mathtt{\{\;G_1\,\}}$*) -> 
                (*new$\mathtt{G_1}$*) = rename_protocol_calls((*$\mathtt{G_1}$*), ScopeEnv)
                return rec t (*$\mathtt{\{\;newG_1\,\}}$*)
            | a(S) from A to B; (*$\mathtt{G_1}$*) ->
                (*new$\mathtt{G_1}$*) = rename_protocol_calls((*$\mathtt{G_1}$*), ScopeEnv)
                return a(S) from A to B; (*new$\mathtt{G_1}$*)
            | continue t ->
                return continue t
            | end ->
                return end
        
    def rename_nested_protocols(nested_protocols, ScopeEnv, ProtocolNames):
        renamed_protocols = (*$\emptyset$*)
        for (nested protocol P((*$\rolessig{A}{n}$*); (*$\scrnew\ \rolessig{B}{m}$*)) {nested_protos; G}) in nested_protocols:
            newP = UNIQUE_NAME(P, ProtocolNames)
            ScopeEnv = ScopeEnv[P -> newP]
            ProtocolNames = ProtocolNames (*$\bigcup$*) {newP}
            renamed_protocols = renamed_protocols (*$\bigcup$*) {(*$\;$*)nested protocol newP((*$\rolessig{A}{n}$*); (*$\scrnew\ \rolessig{B}{m}$*)) {nested_protos; G}(*$\;$*)}
        return (renamed_protocols, ScopeEnv, ProtocolNames)
    \end{lstlisting}
    \caption{Algorithm for renaming protocol interactions}
    \label{renaming-interactions}
\end{figure}
\clearpage

\begin{figure}[h!]
    \centering
    \lstset{language=Pseudocode}
    \begin{lstlisting}[escapeinside={(*}{*)}]
    def rename_and_flatten_protocols(nestedProtocol, ScopeEnv, ProtocolNames, AllProtocols):
        match nestedProtocol with:
          | nested protocol P((*$\rolessig{A}{n}$*); new (*$\rolessig{B}{m}$*)) {nested_protocols; G} ->
            (ScopeEnv, ProtocolNames, nestedProtocols) = 
                rename_nested_protocols(nestedProtocols, ScopeEnv, ProtocolNames)
            for nestedProtocol in nestedProtocols:
              ProtocolNames, AllProtocols = 
                  rename_and_flatten_protocols(nestedProtocol, ScopeEnv, ProtocolNames, AllProtocols)

            newG = rename_protocol_calls(G, ScopeEnv)
            AllProtocols = AllProtocols (*$\bigcup$*) {(*$\;$*)protocol P((*$\rolessig{A}{n}$*); new (*$\rolessig{B}{m}$*)) {(*$\;$*)newG(*$\;$*)}(*$\;$*)}
            return ProtocolNames, AllProtocols
      
    def rename_module(nested_protocols, global_protocols):
        ProtocolNames = (*$\emptyset$*)
        ScopeEnv = {}
        TopLevelProtocols = (*$\emptyset$*)
        AllProtocols = (*$\emptyset$*)
        for (global protocol P((*$\rolessig{A}{n}$*)) {nested_protos; G}) in global_protocols:
          ProtocolNames = ProtocolNames (*$\bigcup$*) P
          TopLevelProtocols = TopLevelProtocols (*$\bigcup$*) {nested protocol P((*$\rolessig{A}{n}$*); (*$\emptyset$*)) {nested_protos; G}}

        renamed_nested_protocols, ScopeEnv, ProtocolNames = 
              rename_nested_protocols(nested_protocols, ScopeEnv, ProtocolNames)
        TopLevelProtocols = TopLevelProtocols (*$\bigcup$*) renamed_nested_protocols
        for top_level_protocol in TopLevelProtocols:
            ProtocolNames, AllProtocols = rename_and_flatten_protocols(top_level_protocol, SetupEnv, ProtocolNames, AllProtocols)

        return AllProtocols

    \end{lstlisting}
    \caption{Algorithm for renaming protocols in a Scribble module}
    \label{renaming-module}
\end{figure}
\clearpage


\section{Projection}\label{scribble-projection}
As in the original paper, projecting a global or nested protocol requires having an environment which keeps track of all the protocols which are in scope. Our definition of projection is defined on the flattened representation of the Scribble module we described in Section \ref{renaming}, where all the protocols are stored in one large set and the distinction between global and nested protocols has been removed. Moreover, in order to successfully rename all the protocols the original Scribble module must have been checked to ensure all protocol calls are valid. From this flattened representation, building the projection environment is a trivial process, where the protocol declarations in the set can be aggregated to create a mapping from protocol names to their role signatures ($P \mapsto \{\roles{A}{n};\ \roles{B}{m}\}$).\\

It is not a problem to store the signatures of all the protocols in the environment, because in the validation step and the renaming process we will have already verified that the scope restriction is not violated, so the protocols will only ever need to look up protocols which are defined in their scope in the projection environment. The definition of projection is undefined for protocol calls to protocols which are not in the environment, but this case should never arise if the protocols have passed the previous validation steps we have described.

\subsection{Projection of Global Protocols}

In order to generate all the local protocols in a Scribble module, we must project every protocol onto every role taking part in it, which will generate a much larger set of local protocols. We define the projection of a Scribble protocol $P$ onto a role $A$ in Figure \ref{scribble-protocol-projection}.

\begin{figure}[!h]
    \begin{center}
        \begin{tabular}{l}
            $(\protocol\ \mathit{P}(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{\mathit{G}\})\project\ =$\\[7pt]
            \begin{math}
                \begin{cases}
                    \mathit{If}\ \mathit{A} \in \{\roles{A}{n},\ \roles{B}{m}\}:\\
                    \scrlocal\ \protocol\ \mathit{A@P}(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{\mathit{G} \project\}\\[8pt]
                    \mathit{Otherwise:} \quad \mathit{undefined}
                \end{cases}
            \end{math}
        \end{tabular}
    \end{center}
    \caption{Projection of a Scribble protocol}
    \label{scribble-protocol-projection}
\end{figure}
% If $A \in \{\roles{A}{n},\ \roles{B}{m}\}$ then:

% $(\protocol\ P(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{G\})\downarrow_A^{Env}\ =$

% $\scrlocal\ \protocol\ A@P(\rolessig{A}{n};\ \scrnew\ \rolessig{B}{m})\ \{G \downarrow_A^{Env}\}$\\

% Otherwise it is undefined. \\


The projection operation on global protocols remains the same as defined in the Featherweight Scribble paper\cite{featherweight} for all constructs except the $\choice$. Figure \ref{featherweight-scribble-projections} shows these definitions, which we have taken from the paper. We denote $\mathcal{P}(G)$ as the set of roles participating in protocol $G$.\\

Previously, the $\scrdo$ construct would be expanded before projection, which we do not do. However, after removing the distinction between global and nested protocols, all calls to global protocols using the $\scrdo$ construct will have been converted to $\calls$, so we also do not need to define a rule for projecting $\scrdo$. \\

\begin{figure}[!h]
    \begin{center}
        \begin{tabular}{l}
            $(\scrmessage{a}{S}\ \from\ \mathit{B}\ \scrto\ \mathit{C};\ G') \project\ =\ $\\[3.5pt]
            \begin{math}
                \begin{cases}
                    \scrmessage{a}{S}\ \scrto\ \mathit{C};\ (\mathit{G'} \project) & \mathit{if}\ \mathit{A}\ =\ \mathit{B}\\[3pt]
                    \scrmessage{a}{S}\ \from\ \mathit{B};\ (\mathit{G'} \project) & \mathit{if}\ \mathit{A}\ =\ \mathit{C}\\[3pt]
                    \mathit{G'} \project & \mathit{otherwise}
                \end{cases}
            \end{math}
            \\\\
            $(\rec\ \mathit{t}\ \{\mathit{G'}\}) \project\ =$\\[3.5pt]
            \begin{math}
               \begin{cases}
                   \rec\ \mathit{t}\ \{\mathit{G'} \project\} & \mathit{if}\ \mathit{A}\ \in\ \mathcal{P}(G')\\
                   \scrend & \mathit{otherwise}
               \end{cases}
           \end{math}
           \\\\
           $(\continue\ \mathit{t}) \project\ =\ \continue\ \mathit{t}$
           \\\\
           $(\scrend) \project\ =\ \scrend$
        \end{tabular}
    \end{center}
 
    \caption{Projection of constructs taken from Featherweight Scribble\cite{featherweight}}
    \label{featherweight-scribble-projections}
\end{figure}

The projection of the $\calls$ construct is very similar to the projection of the protocol call in the original paper\cite{nestedprotocols}, and it considers the same 4 cases. When the projected role is making a call, it must send all the invitations to the other participants, potentially including itself. It must also send external invitations to the new dynamic participants which will take part in the subsession, if any. If there are no dynamic participants, then the $\create$ construct can be omitted. If the projected role is taking part in the subsession, then it must also accept the invitation to the appropriate role in the nested protocol from the caller. If the projected role is neither the caller or a participant in the protocol call, then the protocol call can be ignored. The formal definition of the projection of the $\calls$ construct is shown in Figure \ref{scribble-calls-projection}\\
 
%  $(\scrmessage{a}{S}\ \from\ B\ \scrto\ C;\ G') \project\ =\ $\\[3.5pt]
% \begin{math}
%     \begin{cases}
%         \scrmessage{a}{S}\ \scrto\ C;\ (G' \project) & if\ A\ =\ B\\[3pt]
%         \scrmessage{a}{S}\ \from\ B;\ (G' \project) & if\ A\ =\ C\\[3pt]
%         G' \project & otherwise
%     \end{cases}\\\\
% \end{math}
 
%  $(\rec\ t\ \{G'\}) \project\ =$\\[3.5pt]
%  \begin{math}
%     \begin{cases}
%         \rec\ t\ \{G' \project\} & if\ A\ \in\ \mathcal{P}(G')\\
%         \scrend & otherwise
%     \end{cases}\\\\
% \end{math}
 
%  $(\continue\ t) \project\ =\ \continue\ t$\\
 
%  $(\scrend) \project\ =\ \scrend$\\
 
\begin{figure}[!h]
    \begin{center}
        \begin{tabular}{l}
            $(C\ \calls\ P(\roles{A}{n});\ G') \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}\ =$\\[3.5pt]
            \begin{math}
                \begin{cases}
                    \invite(\roles{A}{n})\ \scrto\ \mathit{P}; & \mathit{if}\ \mathit{A}\ =\ \mathit{C},\ \exists i. \mathit{C}\ =\ \mathit{A_i}\\[0.25pt]
                    \create(\rolessig{B}{m})\ \scrin\ \mathit{P}; & \\[0.25pt]
                    \accept\ \mathit{D_i@P}(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ \mathit{C}; & \\[0.25pt]
                    (\mathit{G'} \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) & \\[13pt]

                    \invite(\roles{A}{n})\ \scrto\ \mathit{P}; & \mathit{if}\ \mathit{A}\ =\ \mathit{C},\ \mathit{C} \notin \{\roles{A}{n}\} \\[0.25pt]
                    \create(\rolessig{B}{m})\ \scrin\ \mathit{P}; &\\[0.25pt]
                    (\mathit{G'} \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) &\\[13pt]

                    \accept\ \mathit{D_i@P}(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ C; & \mathit{if}\ \mathit{A}\ \neq\ \mathit{C},\ \exists i. C\ =\ A_i\\[0.25pt]
                    (\mathit{G'} \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) & \\[13pt]

                    (\mathit{G'} \projectenv{Env,\ \mathit{P}\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) & \mathit{otherwise}
                \end{cases}
            \end{math}
        \end{tabular}
    \end{center}
    \caption{Projection of $\calls$ construct}
    \label{scribble-calls-projection}
\end{figure}

%  $(C\ \calls\ P(\roles{A}{n});\ G') \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}\ =$\\[3.5pt]
%  \begin{math}
%     \begin{cases}
%         \invite(\roles{A}{n})\ \scrto\ P; & if\ A\ =\ C,\ \exists i. C\ =\ A_i\\[0.25pt]
%         \create(\rolessig{B}{m})\ \scrin\ P; & \\[0.25pt]
%         \accept\ D_i@P(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ C; & \\[0.25pt]
%         (G' \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) & \\[13pt]

%         \invite(\roles{A}{n})\ \scrto\ P; & if\ A\ =\ C,\ C \notin \{A_1,\ ...\ ,\ A_n\} \\[0.25pt]
%         \create(\rolessig{B}{m})\ \scrin\ P; &\\[0.25pt]
%         (G' \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) &\\[13pt]

%         \accept\ D_i@P(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ C; & if\ A\ \neq\ C,\ \exists i. C\ =\ A_i\\[0.25pt]
%         (G' \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) & \\[13pt]

%         (G' \projectenv{Env,\ P\ \mapsto\ \{\roles{D}{n};\ \roles{B}{m}\}}) & otherwise
%     \end{cases}\\\\
% \end{math}

\begin{figure}[h!]
    \begin{center}
        \begin{tabular}{l}
            % $\mathtt{MSG\_FROM}(R)\ =$\\

            % $\quad \quad |\ \scrmessage{a}{S}\ \from\ \mathit{R}\ \scrto\ \mathit{C}$\\

            % $\quad \quad |\ \mathit{R}\ \calls\ \mathit{P}(\roles{A}{n})$\\[7pt]

            % $\mathtt{RECV\_FROM}(\mathit{R})\ =$\\

            % $\quad \quad |\ \scrmessage{a}{S}\ \from\ \mathit{R}$\\

            % $\quad \quad |\ \accept\ \mathit{D@P}(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ \mathit{R}$\\[7pt]

            $R_1 = R_2 \implies \mathtt{IS\_MSG\_FROM}(\,R_2,\ \contG{\messageG{a}{S}{R_1}{C}}{G}\;)$\\[7pt]

            $R_1 = R_2 \implies \mathtt{IS\_MSG\_FROM}(\,R_2,\ \contG{\callsG{R_1}{P}{A}}{G}\;)$\\[14pt]

            $R_1 = R_2 \implies \mathtt{IS\_RECV\_FROM}(\,R_2,\ \messageFromL{a}{S}{R_1}\;)$\\[7pt]

            $R_1 = R_2 \implies \mathtt{IS\_RECV\_FROM}(\,R_2,\ \acceptL{D@P}{A}{B}{R_1}\;)$\\[14pt]

            $\mathtt{FIRST\_RECEIVERS}(\,G\,)\ =$\\

            \begin{math}
                \begin{cases}
                    \{B\} & \mathit{if}\ G\ =\ \scrmessage{a}{S}\ \from\ \mathit{A}\ \scrto\ \mathit{B};\ \mathit{G'}\\
                    \{\roles{A}{n}\} & \mathit{if}\ \mathit{G}\ =\ \mathit{A}\ \calls\ \mathit{P}(\roles{A}{n});\ \mathit{G'}\\
                    \emptyset & \mathit{otherwise}
                \end{cases}
            \end{math}
        \end{tabular}
    \end{center}
    \caption{Auxiliary definitions for projection of $\choice$ and merge operator}
    \label{scribble-choice-aux-predicates}
\end{figure}

% Let:

% $\mathtt{MSG\_FROM}(R)\ =$

% $\quad \quad |\ \scrmessage{a}{S}\ \from\ R\ to\ C$

% $\quad \quad |\ R\ \calls\ P(\roles{A}{n})$

% $\mathtt{RECV\_FROM}(R)\ =$

% $\quad \quad |\ \scrmessage{a}{S}\ \from\ R$

% $\quad \quad |\ \accept\ D@P(\roles{A}{n};\ \scrnew\ \roles{B}{m})\ \from\ R$

% $\mathtt{FIRST\_RECEIVERS}(G)\ =$

% \begin{math}
%     \begin{cases}
%         \{B\} & if\ G\ =\ \scrmessage{a}{S}\ \from\ A\ \scrto\ B;\ G'\\
%         \{\roles{A}{n}\} & if\ G\ =\ A\ \calls\ P(\roles{A}{n});\ G'\\
%         \emptyset & otherwise
%     \end{cases}\\\\
% \end{math}

\begin{figure}[h!]
    \begin{center}
        \begin{tabular}{l}
            $(\choice\ \at\ \mathit{B}\ \{\mathit{G_i}\}_{i \in I}) \project\ =$\\[3.5pt]
            \begin{math}
               \begin{cases}
                   \choice\ \at\ \mathit{B}\ \{(\mathit{G_i} \project)\}_\varinset{i}{I} & \mathit{if} \mathit{A}\ =\ \mathit{B}\ \mathit{or}\ \mathit{A}\ \in\ \displaystyle \bigcap_\varinset{i}{I}\ \mathtt{FIRST\_RECEIVERS}(\mathit{G_i})\\
                   \displaystyle \bigsqcup_\varinset{i}{I}\ (\mathit{G_i} \project) & \mathit{otherwise}\\
               \end{cases}
           \end{math}\\\\
           
           \textit{if} $\forall \varinset{i}{I}.\mathtt{IS\_MSG\_FROM}(\,B,\; G _i\,)$\\[10pt]
           \textit{Otherwise it is undefined}
        %    \quad $\bullet$ $\bigsqcup$ is the full merge operator, which is defined in Figure \ref{fullmerge}
        \end{tabular}
    \end{center}
    \caption{Projection of $\choice$ extended with invitations}
    \label{scribble-choice-projection}
\end{figure}

% We then define the projection of $\choice$ as:\\

%  $(\choice\ \at\ B\ \{G_i\}_{i \in I}) \project\ =$\\[3.5pt]
%  \begin{math}
%     \begin{cases}
%         \choice\ \at\ B\ \{(G_i \project)\}_\varinset{i}{I} & if A\ =\ B\ or\ A\ \in\ \displaystyle \bigcap_\varinset{i}{I}\ \mathtt{FIRST\_RECEIVERS}(G_i)\\
%         \displaystyle \bigsqcup_\varinset{i}{I}\ (G_i \project) & otherwise\\
%     \end{cases}\\[2pt]
% \end{math}

% where:
% \begin{itemize}
%     \item $G_i\ =\ \mathtt{MSG\_FROM}(B)_i;\ G'_i$
%     \item $\bigsqcup$ is the full merge operator, which is defined in Figure \ref{fullmerge}
% \end{itemize}
 

% Otherwise, the projection of $\choice$ is undefined.\\

The Scribble $\choice$ construct does not have a very well-defined semantics and projection definition. Different implementations of Scribble may have slightly different definitions about what constitutes a well-formed choice.  We base our definition on the Multiparty Session Types\cite{gentleintrotompst} and the definition given in the Featherweight Scribble paper\cite{featherweight}. We define the projection of the $\choice$ construct in Figure \ref{scribble-choice-projection}.\\


Before taking nested protocols into account, we define a $\choice$ contruct as a directed choice from the participant making the choice, e.g. $\mathtt{B}$, to a single participant, which receives a distinct first message from $\mathtt{B}$ in each choice branch. This first message will allow the receiving role to identify the choice $\mathtt{B}$ makes. However, with the addition of nested protocols and invitations, labeled messages $\scrmessage{a}{S}$ are not the only type of messages which can be sent. A protocol call involves sending invitations to different roles, and receiving different invitations will also allow participants to discern which choice $\mathtt{B}$ makes. Therefore, we allow having combination of protocol calls and message exchanges initiated by $B$ as the first interactions in the $\choice$ branches.\\

In order to enforce this restriction, we define an auxiliary predicate \texttt{\seqsplit{IS\_MSG\_FROM(R,\ G)}}, which can be seen in Figure \ref{scribble-choice-aux-predicates}. We define two rules from which this predicate can be derived, one for a protocol call and one for a labeled message exchange. The rules specify that in order to derive the predicate, the role which is the first parameter in the predicate must also be the sender of the message in the first interaction of the global type. Then, in the definition of the projection of $\choice$ we require that the global type of each branch satisfies the predicate $\mathtt{IS\_MSG\_FROM}(\,B,\ G_i)$, where \textit{B} is the role making the choice.\\

On top of this restriction, we still require that each first message is unique in each branch. We consider that two protocol calls are equal only if the protocol name is the same and the same participants are invited to carry out the same roles in the called protocol, and two labeled messages are the same if both the labels and all the payloads are the same.\\

Taking invitations into account makes it possible for a $\choice$ to not have a single first receiver, because during the setup of a protocol call multiple invitations are sent out in parallel. Any of the roles which receive one of these invitations could potentially be considered as the first receiver in the $\choice$. We therefore build the set of possible receivers as the intersection of the first receivers in each branch. This intersection must not be empty for the choice to be valid. As before, sending a labeled message restricts the possible candidates to the receiver of the message. We extract this information from the global types of each branch with the function $\mathtt{FIRST\_RECEIVERS}(G)$.\\

Moreover, because the sending of invitations is asynchronous and a role can send an invitation to itself, it is valid to have a $\choice$ where the role making the choice is also a potential first receiver. This can occur if each branch of the $\choice$ starts with a protocol call in which that role also participates. However, this cannot happen if any branch starts with a labeled message exchange, as it is invalid for a role to send a message to itself.\\


We extend the definition of projection for $\choice$ for the case where the projected role is not the role making the choice  or one of the roles receiving the first message. The definition proposed in the nested protocols paper only applied a simple merge over all the branches, where the continuation of the role in each of the branches must be exactly the same. We apply a variation of the full merge presented in the Featherweight Scribble paper\cite{featherweight} instead, modified to take into account both invitations and labeled messages. A definition of the full merge can be seen in Figure \ref{fullmerge}.\\

% \begin{figure}[h]

%     \centering

%     $\mathit{T_1}\ \bigsqcup\ \mathit{T_2}\ =\ \mathit{T_1} \quad \; \mathit{if}\ \mathit{T_1}\ =\ \mathit{T_2}$\\[17pt]

%     $\choice\ \at\ \mathit{B}\ \{\mathtt{RECV\_FROM}(\mathit{B})_i;\ \mathit{T_i}\}_\varinset{i}{I}\ \bigsqcup\ \choice\ \at\ \mathit{B}\ \{\mathtt{RECV\_FROM}(B)_j;\ \mathit{T'_j}\}_\varinset{j}{J}\ =$\\[5pt]
%     $\choice\ \at\ \mathit{B}\ \{\mathtt{RECV\_FROM}(\mathit{B})_i;\ T_i\}_\varinset{i}{I\;\setminus\;J}\ \bigcup\ \{\mathtt{RECV\_FROM}(\mathit{B})_j;\ \mathit{T'_j}\}_\varinset{j}{J\;\setminus\;I}\ \bigcup$\\
%      $\{\mathtt{RECV\_FROM}(\mathit{B})_k;\ \mathit{T_k}\ \bigsqcup\ \mathit{T'_k}\}_\varinset{k}{I\;\cap\;J}$\\[17pt]

%     % $\rec\ t\ \{T_1\}\ \bigsqcup\ \rec\ t\ \{T_2\}\ =\ \rec\ t\ \{T_1\ \bigsqcup\ T_2\}$\\[13pt]

%     % $\continue\ t\ \bigsqcup\ \continue\ t\ =\ \continue\ t$\\[13pt]

%     % $\scrend\ \bigsqcup\ \scrend\ =\ \scrend$\\[13pt]

%      $\mathit{T_1}\ \bigsqcup\ \mathit{T_2}$ \ \ \textit{is undefined otherwise}\\[7.5pt]

%     \caption{Definition of the full merge operator}
%     \label{fullmerge}
% \end{figure}

\begin{figure}[h]

    \centering

    $\mathit{T_1}\ \bigsqcup\ \mathit{T_2}\ =\ \mathit{T_1} \quad \; \mathit{if}\ \mathit{T_1}\ =\ \mathit{T_2}$\\[17pt]

    $\choice\ \at\ \mathit{B}\ \{\mathit{RecvMsg_i}\;;\ \mathit{T_i}\,\}_\varinset{i}{I}\ \bigsqcup\ \choice\ \at\ \mathit{B}\ \{\mathit{RecvMsg_j}\;;\ \mathit{T'_j}\,\}_\varinset{j}{J}\ =$\\[5pt]
    $\choice\ \at\ \mathit{B}\ \{\mathit{RecvMsg_i}\;;\ \mathit{T_i}\,\}_\varinset{i}{I\;\setminus\;J}\ \bigcup\ \{\mathit{RecvMsg_j}\;;\ \mathit{T'_j}\,\}_\varinset{j}{J\;\setminus\;I}\ \bigcup$\\
     $\{\mathit{RecvMsg_k}\;;\ \mathit{T_k}\ \bigsqcup\ \mathit{T'_k}\,\}_\varinset{k}{I\;\cap\;J}$\\[7.5pt]

    %  \textit{if} $\forall \varinset{i}{I}.\mathtt{IS\_RECV\_FROM}(\,B,\; \textit{RecvMsg_i}\,)\ \mathit{and}\ \forall \varinset{j}{J}.\mathtt{IS\_RECV\_FROM}(\,B,\; \mathit{RecvMsg_j}\,)$\\[17pt]

    $\mathit{if}\ \forall \varinset{k}{I\;\cup\;J}.\;\mathtt{IS\_RECV\_FROM}(\mathit{B},\ \mathit{RecvMsg_k\,})$\\[14pt]

    % $\rec\ t\ \{T_1\}\ \bigsqcup\ \rec\ t\ \{T_2\}\ =\ \rec\ t\ \{T_1\ \bigsqcup\ T_2\}$\\[13pt]

    % $\continue\ t\ \bigsqcup\ \continue\ t\ =\ \continue\ t$\\[13pt]

    % $\scrend\ \bigsqcup\ \scrend\ =\ \scrend$\\[13pt]

     $\mathit{T_1}\ \bigsqcup\ \mathit{T_2}$ \ \ \textit{is undefined otherwise}\\[7.5pt]

    \caption{Definition of the full merge operator}
    \label{fullmerge}
\end{figure}

Two local types can always be merged if they are the same type. Two $\choice$ constructs can be merged if the same role is making the choice, and the first interaction in every branch is the receiving of a different message (invitation or labeled message) from that role. We express this by ensuring that the local type of each branch starts with a \textit{RecvMsg} (defined in Section \ref{scr-local-protocols-syntax}), which can either be the receiving of a labeled message or an $\accept$ construct. Moreover, we enforce that the sender of the first message in all branches must be the role making the choice by requiring that the local type of every branch satisfies the predicate \texttt{IS\_RECV\_FROM}($\mathit{B}$, $\mathit{RecvMsg_k}$), where $\mathit{RecvMsg_k}$ is the first interaction in each branch. We define two rules to derive this predicate in Figure \ref{scribble-choice-aux-predicates}, where the predicate can only be derived if the role passed in as a parameter is the one sending the message in the local type.\\

The resulting merged type in this case is a $\choice$ which combines the branches from both types. The branches which do not overlap between the two $\choice$ constructs can remain the same, but the branches where the first received message is common to both of them must be recursively merged to produce a new type. To reduce the number of cases to consider in the definition of the merge operator we implicitly use the equivalence between a $\choice$ with a single branch and the interactions of that branch without the $\choice$: $\choice\ \at\ R\ \{T\}\ \equiv\ T$.\\
 
% TODO: Find a better name
\chapter{Code Generation}
% Intro about approach

% TODO: Move to next chapter
% The code generation approach is different from the one previously discussed, as the code is generated directly from the session types. We describe the Scribble language extensions and the code generation approach to produce Golang APIs.
In this chapter we describe our approach towards implementing Golang APIs for nested protocols defined in the Scribble protocol description language. 

\textbf{TODO: intro}
% We describe how the protocol implementation is structure and how it can be integrated into a 

% Our code generation approach is slighlty different from the normal Scribble pipeline which was described in Section \ref{Scribble}. We do not generate a communication finite state machine from the local protocols of each of the protocols participants, but rather generate the implementation of each of the participants directly 

\section{Code Generation Approach}\label{codegen-approach}
Our code generation approach is slightly different from the one normally used in Scribble, which we described previously in Section \ref{Scribble}. We do not generate a communication finite state machine (CFSM) from the local protocol of each of the roles, but rather generate code directly from the local type. The main obstacle in creating a CFSM is that it is not possible to encode properly nested sessions using a CFSM. In order to do this, we would need to create some kind of Stacked CFSM which would keep track of the stack of protocol calls in order to know which state to return to after the protocol call had finished. Compared to this, generating code directly from the local type is simpler, and it also allows us to design a scheme which directly encodes the behaviour of the local type into the Go programming language. We describe this scheme in Section \ref{local-protocol-codegen}.

\subsection{Implementation Design Overview}
Here we provide a high-level description of the main components which we have used in implementation of nested protocols. A more detailed breakdown of each each component and how we have structured them is given in Section \ref{project-structure}. \\

When coming up with the design of the implementation of nested protocols, we wanted the approach to be as simple and intuitive to use as possible. Because our target language was Golang, we wanted to take advantage of the in-built concurrency primitives of the language: shared-memory channels and goroutines.\\

In our implementation, participants execute in parallel as different goroutines, and the dynamic participants in nested protocols are created as new goroutines every time a protocol call is made. All communications between participants are carried out over channels. We create structs for the different kinds of messages in a protocol, and store all the different structs needed by a role for all its message exchanges in a struct. Each role also has a struct containing all the channels it needs to send and receive invitations. Our invitations consist of two structs, the first one containing the channels that a participant will need to carry out the interactions of the role they will be undertaking, and the second one containing the channels that they will need in order to initiate and participate any protocol calls as their new role. \\

% TODO: Justify having one channel per interaction?
Each channel that a role has will only be used once, regardless of whether it is used for sending or receiving a message or an invitation, which means that a role will have as many channels as the number of messages it sends and receives.\\

% TODO: Cite for callbacks approach
When generating the implementation of the role, we also generate an interface which contains the signatures of different methods which are called from the role's implementation. This allows the user to define the protocol's behaviour without modifying the implementation of the protocol which is automatically generated. An instance of the interface is used to maintain the role's state throughout the protocol by calling the interface's methods. These callbacks can provide new information which was received, such as a received labeled message, or allow the user to provide input needed for the execution, such as producing the message which will be sent or deciding which branch of a $\choice$ to follow. Similar approaches to this one using callbacks has been used in other implementations of Scribble such as [\textbf{TODO}].\\

The implementation of a role is generated as a self-contained function, which only contains the interactions defined in the local protocol. Calls to nested protocols involve an initial setup phase which is initiated by the role which is the caller of the protocol. During this setup, the invitations for all the roles are created: the new channels needed by all the roles are created and aggregated to create the channel and invitation structs for all of the roles. These structs are sent to all non-dynamic participants through their invitation channels. Dynamic participants also receive their channels, but they receive them directly when they are spawned as new goroutines which execute the functions corresponding to the role's implementation. Once the invitations are sent, a role participating in the protocol call simply needs to accept their invitation, create the callbacks environment for their new role and then call the function which implements the behaviour of that role.\\

In our implementation, we also attempt to tackle the problem of returning information from a protocol call, which was outlined in the original paper\cite{nestedprotocols} and we describe in Section \ref{nested-protocols-return-value}. To solve it, we define result structs for every non-dynamic role of each protocol. The function implementing the behaviour of these roles will return its corresponding result struct, which can be aggregated into the state of the caller through a callback. The result struct can be generated from a role's state, and it is returned by the last callback that is called in the implementation: \texttt{Done()}, which signifies that the role has finished executing all its interactions. The user can fill the structs with whatever information it wants the role to bring out of the subsession.\\

Although this return value is only the partial state of each role, not a return value for the protocol as a whole, it is a simple mechanism which allows roles to retain part of their state after executing in a nested session without introducing any additional messages. This is already a massive improvement over not being able to retain any information at all. However, this solution is not fully satisfactory for the entry-point protocol, which should only be called once to setup all the initial roles and produce a single result for that protocol. Our proposal to solve this problem is to aggregate the results of all the roles into a single state which the user can access outside of the protocol. We create an interface which accepts the result of each of the initial roles in the entry-point protocol, allowing the user to define an implementation of the interface which aggregates all these return values in a useful way. However, this solution is not ideal, and we will continue to discuss this part of the design and its limitations in Section \ref{entry-point}.\\

When setting up the entry-point protocol, the process is very similar to the setup for a protocol call. All the channels for the roles must be created, but instead of receiving their channels as invitations, the roles execute as new goroutines which receive the channels as parameters directly. In order to synchronize the ending of the protocol, we use one of Golang's synchronization mechanisms: \texttt{sync.WaitGroup}. A wait group has an internal counter which specifies the number of pending jobs which should finish before resuming execution. The main thread waits on the waitgroup until all the goroutines of the initial participants finish executing. Every time a dynamic participant is created, the wait group's counter must be increased to ensure that execution does not continue before all the participants, including the dynamic participants, have finished executing.

\section{Implementation Restrictions}\label{implementation-restrictions}
In Chapter \ref{scribble-extensions-chapter} we have described the Scribble syntax for defining protocols with nested protocols. Our Scribble extensions allow the user to define complex dependency graphs between protocols with mutual recursion, to shadow definitions of nested protocols with the same name in different scopes, while placing very few restrictions with regards to how things should be named.\\

Translating the declaration of a protocol defined in a language which gives the user so much freedom about how things are named and structured to a programming language with stricter restrictions like Golang is a great challenge. We have tried to come up with a design for the implementation which is simple and easy to use, but in order to do so we have had to place a set of small restrictions on the user when defining the protocols in order to generate their implementation. However, the framework will only try to enforce these restrictions when trying to generate the Golang implementation - these checks will not be made, for instance, if the user only wants to display the projection of a protocol.\\

\subsection{Code Organisation in Golang}

% TODO: Move these things around
Golang programs are organised into packages, which are a collection of source files which are compiled together. Functions, types, structs and constants defined in a source files are visible to all the other source files in the same package\cite{godocs}. This means that generating two of these constructs with the same name in the same package will produce an error, even if the declarations are in different source files. Moreover, Golang uses capitalisation in order to determine the visibility of the constructs declared within a package - if they start with a capital letter then they can be accessed outside the package, otherwise they can only be accessed within the package.\\

It is invalid to have cyclic import dependencies between different packages in a codebase, but there are different strategies for solving this issue: from placing the files which depend on one another in the same package to declaring interfaces to remove the coupling between the implementation of the packages.\\

By convention, package and source file names tend to be short, single-word names which are all lowercased, and it is not possible to define two packages with the same name in the same directory. However, for multiword names, the convention is to use mixed caps rather than underscores: \texttt{MixedCaps} or \texttt{mixedCaps} rather than \texttt{snake\_case}.\\

\subsection{Naming Restrictions}\label{naming-restrictions}

The lack of any enforceable naming conventions in Scribble makes it quite difficult come up with a consistent naming scheme for the different parts of the implementation. We aim to adhere to the existing naming conventions in Golang wherever possible. However, one of the main concerns while generating names for types and functions is to ensure there are no name clashes within the same package. In order to simplify the code generation process and produce meaningful names for the variables and constructs, we placed the following constraints on the names of the Scribble protocols, labeled messages and role names:

\begin{itemize}
    \item Protocol names must be unique when the case is ignored. Lowercased protocol names are used as package names, following the Golang naming convention. The uniqueness of protocol names we currently guarantee through the renaming process described in Section \ref{renaming} is currently case sensitive, which means two protocols \texttt{"P1"} and \texttt{"p1"} are considered to be different. This stronger uniqueness property is only required for code generation, so it is not necessary to enforce it at an earlier stage.
    \item Message labels must be unique when capitalised within any protocol. We generate a new struct for every kind of labeled message using the message's label, and in order for the structs to be visible outside the package, they must be capitalised. It is therefore necessary to enforce this restriction. We also require labeled messages to have a consistent set of fields throughout their uses within a protocol, because we only define one struct per label name. It would be possible to generate a different structs for different uses of the same label, but it this might not be as clear to the user. We have decided instead to push the responsability of disambiguating labeled messages to the user, but it should not be hard for the user to work around this restriction.
    \item Role names within a protocol must also be unique when case is ignored. This restriction is necessary, because we use role names to generate the names for many different structs and functions, and it makes it easier to generate unique names. The need for this restriction may be clearer once the naming scheme we use has been explained in Section \ref{naming-and-notation}.
\end{itemize}

While these restrictions will not enforce that our implementation follows the naming conventions in Golang, they are useful to ensure that the constructs we generate are unique within a package. Moreover, the naming scheme we have chosen, which we describe in Section \ref{naming-and-notation}, aims to produce meaningful names which closely resemble the declarations in the Scribble module so that the user can easily understand the generated codebase.

\subsection{Package Organisation Restrictions}

One of the big factors which conditioned our design was cyclic imports. Ideally, we would have wanted to achieve a highly-modular design with the implementation of every protocol within its own module. After all, modularity is one of the main features that nested protocols can provide. However, the ability to define mutually recursive protocols in Scribble means that any two protocols can potentially depend on one another, whether directly or indirectly. This means that their implementations will also be linked in some way, and therefore, it is not possible to define the whole implementation of each protocol within a different package, as the dependencies between protocols would cause cyclic imports.\\

Our design therefore tries to split up the implementation of each protocol into different components, and keeps each of the source files for each of the components in different packages whereever possible. We describe the role of each of the components in Section \ref{directory-structure}.


% \lstset{language=Go}
% \begin{lstlisting}
%     func x(A []int) {
%         make(chan int)
%     }
% \end{lstlisting}

% Golang Restrictions:
% Package name conventions
% Visibility through capitalisation
% Package structure uniqueness (functions, structs, interfaces)
% Cyclic imports

% Naming restrictions:
% protocol names must be unique when case is ignored
% message names must be unique when capitalised
%   - Also enforce consistent use of message label within each protocol for simplicity of implementation: message label will always have the same payload fields and types (it does not restrict the user very much)
% message payload names must be unique when capitalised
% role names must be unique when case is ignored


\section{Naming Scheme and Notation}\label{naming-and-notation}
TODO: Remove this section


% One of the main aims when developing the the code generation scheme was to produce readable code which the user would be able to understand and use with relative ease. This meant that we had to ensure that the names we generated for variables, functions and types were all readable so that a user who writes the protocol specification can understand the purpose of each of the constructs generated. As we mentioned in Section \ref{naming-restrictions}, we have had to place several small restrictions on what the names which the user can use in a protocol can be. These restrictions are useful in order to meet our objective of generating meaningful names, as they allow us to use the names from the Scribble protocol declarations without having to make a lot of changes to ensure there are no name clashes within the different packages.\\

% We will now describe the naming scheme we have developed for our implementation and define the notation we will use in the definition of our code generation scheme in Sections \ref{project-structure} and \ref{local-protocol-codegen}.

% NOTATION
% \newcommand{\pkgname}{{\color{mauve}\mathtt{protocol\_\,pkg}}}
% NOTATION

% \begin{itemize}
%     \item $\pkgname$
% \end{itemize}
% Define text format for different unique name variables:

% role, 
% local protocol,
% protocol,
% payload fields,
% message label,
% choice enum,
% callback,
% environment,
% start env,
% protocol setup function,
% role implementation function

% message struct 
% channel struct
% invitation struct

% env, wg, roleChannels, inviteChannels - variables


% briefly mention naming scheme used in current implementation
% Which naming conventions in go we have not respected and why (hard to generate meaningful names :(  )


\section{Project Structure}\label{project-structure}

% TODO: Rephrase with new contents
We now proceed to discussed how we have structured our implementation and how these different components work together to implement the protocol's behaviour. The implementation of a protocol is split across seven different packages which each encapsulate the different components. As far as possible, we have tried to keep the implementation of different protocols in separate packages. However, there are cases where this is not possible due to limitations in the programming language itself, such as cyclic imports. We will discuss these limitations in Section \ref{implementation-restrictions}.

\subsection{Preliminary Notation}
In Section \ref{codegen-approach} we described from a high-level point of view how our code generation approach worked. However, before explaining how all the different parts of our implementation work in more detail we must first introduce some notation that we will use to name the different components, from packages names to the names of functions, structs and variables. We present here the first few pieces of notation which we will be using, but we will also introduce more notation as we explain the different parts of our implementation. A summary of all the different notations we introduce can be found in Section \ref{notation-summary}. In some cases, the notation we use will help us hide some of the complexity which might arise from trying to enforce that all the names we produce are unique.

% NOTATION
\definecolor{purple}{rgb}{0.415, 0.035, 0.827}
\definecolor{dkorange}{rgb}{0.870, 0.427, 0.007}
\newcommand{\protocolname}[1]{{\mathit{#1}}}
\newcommand{\rolename}[1]{{\mathit{#1}}}
\newcommand{\localprotocol}[2]{{\mathit{#1}@\mathit{#2}}}
\newcommand{\localprotocolname}[2]{{\mathit{#2}\_\mathit{#1}}}
\newcommand{\varname}[1]{{\mathtt{#1}}}
\newcommand{\typename}[1]{{\color{dkorange}\mathtt{#1}}}
% NOTATION


\begin{itemize}
    \item $\protocolname{protocol}$: This denotes a unique global protocol name which was generated after the renaming phase described in Section \ref{renaming}.
    
    \item $\rolename{role}$: This denotes the name of a role participating in a protocol.
    
    \item $\localprotocol{role}{protocol}$: This denotes the unique name corresponding to the local protocol which is the result of projecting the protocol $\protocolname{protocol}$ onto $\rolename{role}$.
    
    In our current implementation, our naming scheme would generate the local protocol name for the local protocol $\localprotocol{role}{protocol}$ as $\localprotocolname{role}{protocol}$. This scheme on its own is not guaranteed to be unique even if protocol names are globally unique and the roles participating in a protocol are also unique, so we have to do extra work to ensure that there are no name clashes. However, in our definitions we will use this notation to abstract away the implementation details.

    \item $\varname{var\_name}$: We will use this style to write varible names in code generation snippets. For simplicity, in the code generation we assume that every variable we create has a new name. Golang has two operators for assignment: \texttt{:=} and \texttt{=}, where the first one creates (at least) one new variable in the left hand side, and the second one assigns to existing variables. Trying to assign to a variable which is already defined in the same scope using the \texttt{:=} operator, or trying to use the \texttt{=} operator to assign to a variable which has not been defined yet will produce an error. Therefore, by restricting ourselves to always creating new variables we can avoid having to keep track of which variables already exist and always use \texttt{:=} for our assignments.
    
    \item $\typename{type}$: We will use this style when defining types in our implementation.
\end{itemize}


\subsection{Directory Structure}\label{directory-structure}

The protocol implementation we generate is all contained within a single package with the same name as the protocol, all lowercased. The different components of the implementation, which we described in Section \ref{codegen-approach} are split into seven packages. Also, wherever possible, we have further split the components of each protocol into their own subpackage. Each of the subpackages contains their own set of logic, and we have set these divisions to ensure that there will never be any cyclic imports between packages. We show this directory structure in Figure \ref{project-package-structure}.

\begin{figure}[h!]
    \centering
    \begin{minipage}{5cm}
    \dirtree{%
    .1 protocol\_pkg.
    .2 messages.
    .3 protocol\_pkg.
    .2 channels.
    .3 protocol\_pkg.
    .2 invitations.
    .2 results.
    .3 protocol\_pkg.
    .2 callbacks.
    .2 protocol.
    .2 roles.
    }
        
    \end{minipage}
    \caption{Package structure for implemenatation of a protocol}
    \label{project-package-structure}
\end{figure}

TODO: Explain figure and introduce notation for refering to pkgs in code and imports.

TODO: Explain purpose of 

% Overview of different packages and considerations for this design over others - eg. cyclic imports (cannot completely encapsulate all functionality of one module )

A brief description of the purpose of each package is given below:
\begin{itemize}
    \item \texttt{messages/<protocol>}
    \item \texttt{channels}
    \item \texttt{messages}
    \item \texttt{messages}
    \item \texttt{messages}
    \item \texttt{messages}
    \item \texttt{messages}
\end{itemize}

roles/ - implentation of the behaviour of all the roles and the setup code for all the protocols.

invitations/ - definition of structs containing channels to send 
invitations/receive invitations

channels/<protocol> - definition of structs for the different roles in the protocl, each containing all the channels they will need 

messages/<protocol> - definition of structs containing the payload for the different messages in a protocol.

protocol/ - entry point for the protocol implementation.

results/protocol - declaration of the structs to return once a role finishes executing (except dynamic roles)

callbacks/ - declaration of interfaces of the environments to allow the user to define the behaviour of the protocol.


\subsection{messages}
\subsection{channels}
\subsection{invitations}
\subsection{results}
\subsection{callbacks}
Need flat structure/can't split interfaces by protocol because roles may need to return a new environment of a different protocol. If the environments are defined within the same file as the interfaces, then it could cause cyclic imports.
\subsection{protocol}\label{entry-point}
\subsection{roles}
Setup for protocols needs to be defined here because it setup phase needs access to roles pkg to initialize dynamic participants, but roles pkg needs access to setup pkg to setup a nested protocol call.
\subsubsection{recursion}

\subsection{Summary of Notation}\label{notation-summary}
    

\section{Implementation of Local Protocols}\label{local-protocol-codegen}
% macros 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{Contribution}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{Experimental Results}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{Conclusion}

\chapter{Notes}

\section{Issues}
\subsection{Code generation}
\begin{itemize}
    \item \textbf{Cyclic imports}:
    
    
    (Nested) protocols can call each other, having mutually recursive chains of calls. This means that the implementations of the roles for different protocols cannot be in different packages, as doing so would cause a cyclic import error, because the implementation of roles in one package would call functions in the other package, and vice versa.
    
    Similarly, the functionality for setting up a call to a nested protocol cannot be in a separate package from the implementation of the roles for the protocols, as the setup will involve calling the implementation of the dynamic participants in the subprotocol, and some of the roles will rely on the setup function when preparing a call to the nested protocol. 
    
    States in callbacks may also depend on one another, as a call to a nested protocol will involve creating the state for that role in the nested protocol from the 
    
    \item \textbf{Waiting for dynamic participants}:
    
    Initially, it seemed that creating a \texttt{WaitGroup} to wait for all of the initial participants in the protocol to finish might be enough. However, after looking at several examples it became apparent that this was not the case. In nested protocols, dynamic participants could take much longer to complete all their interactions than the initial participants. This could happen for example when the initial participants carry out multiple calls to nested protocols, sending only a few messages at the start before finishing their roles. If there still remain interactions between dynamic participants (only), not waiting for all the dynamically started participants would end the protocol prematurely. 
    
    \item \textbf{Invitations}: We will consider invitations as a special kind of message sent between participants. Therefore, an invitation can be a valid message to determine which branch of a choice has been chosen as long as the invitation is a unique first message amongst all the branches of the choice - sending different invitations for the same protocol is also valid. From an implementation perspective, invitations are messages containing a struct with the channels that the participant will need to communicate with the other participants in the nested protocol. This set of channels will be fresh in order to guarantee a separation between the parent and child sessions.

    Roles in both global and nested protocols will have a separate set of channels stored in a struct which can be used to send and receive invitations to/from other participants in the same protocol. We chose to keep these channels separate from the other channels used to communicate with other participants because they are used to spend these special kinds of messages. However, this meant that the invitation channels' struct also had to include channels to send the invitation channels struct that the participant will use to send invitations in the nested protocol. Therefore, at the implementation level, our invitations consist of two messages, one for struct containing the channels the role will use to communicate with other participants and another one the struct containing the channels the role will use to send and receive invitations.
    
    Sent asynchronously. 
    Link to well-formed choice over synchronous channels, and allowing processes to proceed as soon as possible.
    
    \item \textbf{Well-formed choice}: In order for a choice to be well-formed, all roles in the choice must receive a distinct/unique first message from an enabled participant. This choice message must be sent over a dedicated channel used only for this choice. As discussed previously, invitations are sent asynchronously. If there was a single channel to send \texttt{Msg2()} between \texttt{A} and \texttt{B}, then \texttt{B}, who does not participate in \texttt{NestedProto}, will be able to continue sending \texttt{Msg2()} after it sends the invitations for \texttt{NestedProto}. This means that there will be a race as to which message \texttt{A} will receive first, because \texttt{A} would be waiting to receive either the invitation for \texttt{NestedProto} or \texttt{Msg2()} \textit{on the same channel} which \texttt{B} used to send \texttt{Msg2()} in the first branch. If \texttt{Msg2()} were received first, then the protocol would be stuck in a deadlock, because \texttt{A} would mistakenly identify the second branch as the branch which \texttt{B} chose. Therefore, \texttt{A} would be stuck waiting for a message from \texttt{B} which would never come, since \texttt{B} would be waiting for \texttt{Msg3()} from \texttt{A}.
    
    Otherwise, if the channel used to receive the choice message is the same as a channel used to send a message in some branch, there might be a deadlock, as the non-choice message might be sent and received before the actual choice message for a different branch was received. This would cause the participant to think wrongly identify the execution branch which was chosen. For example, in Figure \ref{deadlock} if there were not separate channels for Msg2() in the first branch and Msg2() in the the second branch then if channels were asynchronous.
    
\begin{figure}[h]
\centering
\lstset{language=Scribble}
\begin{lstlisting}

nested protocol NestedProto(role X; new role Y) {
    [...]
}

global protocol Deadlock(role A, role B) {
    choice at B {
        B calls NestedProto(A);
        Msg2() from B to A;
        Msg3() from A to B;
    } or {
        Msg2() from B to A;
        Msg4() from B to A;
    }
}

local protocol Deadlock_A(self A, role B) {
    choice at B {
        accept X from B in NestedProto_X(self; new Y);
        Msg2() from B;
        Msg3() to B;
    } or {
        Msg2() from B;
        Msg4() from B;
    }
}

local protocol Deadlock_B(role A, self B) {
    choice at self {
        invite(A as X) in NestedProto;
        create(role Y) in NestedProto;
        Msg2() to A;
        Msg3() from A;
    } or {
        Msg2() to A;
        Msg4() to A;
    }
}

local protocol NestedProto_X(self X, role Y) {
    [...]
}
    \end{lstlisting}
    \caption{Choice ambiguity}
    \label{deadlock}
\end{figure}{}

    \item \textbf{Code gen design choices:}
    
    - Synchronous channels
    
    - Always send invitations over channels - unifority and single setup() function which can be called by different participants from different protocols
    
    - (Provisional) Callbacks using interfaces (structs which maintain state). Nested role may return result to caller function - this \textbf{will} \textbf{probably} be \textbf{removed}.
    
    - Probably do not allow protocols which do not have at least two participants??
    
    TODO: More elaborate examples and translation scheme from scribble to go. Possibly formalize Scribble projection as well.
    
    Possible two passes - one for channels and one for code generation
    
    Setup 
    
    \item \textbf{Code Gen} - name clashes
    Eg. consider when a nested and not nested protocol are defined at the top level. They are both "different" since one is called through do and the other through calls, and only one of them is a "nested" protocol. Handle through prefixing (eg. nested\_<proto>).
    
    \item \textbf{Scribble language extension} - design
    
    \textbf{Global Types}
    \begin{itemize}
        \item Allow nested protocols to be defined at the top level as well as nested within other global and nested protocols, before any of the protocol's interactions. However, restrict the order of the declarations. All nested protocols at the top level have to be defined before the global protocols. This does not affect the expressiveness of the language, it is just a structural limitation which simplified parsing. 
        \item Use "nested protocol" header to define a nested protocol
        \item Split the roles in a nested protocol's role declaration into two to distinguish dynamic from non-dynamic participants 
        \item Add new syntax for calling nested protocols: <role> calls <proto>(R1, ..., RN);
        This was to ensure that this new construct did not clash with the existing "do <proto>" construct which was used to call other global protocols. Each of the two constructs can be used to call nested/global protocols, but trying to call a nested protocol with 'do' or a global protocol with 'nested' would be invalid. However, at an implementation level, both are treated in the same way.
        \item Scopes
        
        Nested protocols introduce the notion of scopes to Scribble's protocol language. Before, everything was defined at the top level, so there was a single scope where protocols could be defined. However, nested protocols can be defined inside other protocols as well as at the top level, so it is important to ensure that protocols can only call protocols which are in scope. Much like functions in some programming languages, a protocol defines its own scope. All protocols within one scope are visible to one another, meaning that it is possible to define mutually recursive protocols. 
        
        Allowing scope definition can result in cases whose behaviour might not be very intuitive. If you define a nested protocol with the same name as the parent, any reference in the parent protocol's interactions to that name with call the nested protocol, not itself, because it shadows previous definition.
        
        \item Nested protocols, like global protocols must have at least two participants. Global protocols can only have 'static' participants, they cannot have dynamic participants. On the other hand nested protocols can have zero or more dynamic participants, but they must always have at least one non-dynamic participant. 
        
        Allowing a nested protocol to not have any dynamic participants does not impact the implementation in any way and allows greater flexibility when defining protocols. A nested protocol without dynamic participants is essentially the same as a global protocol, except that it's possible to define it inside other protocols, thereby restricting the scope from which it can be called.
        
        The restriction of having at least one (active) role which is not dynamic ensures that the protocol it is always possible for information to reach all the participants in a protocol. Allowing protocols made up of only dynamic participants means that a set of new participants would be brought together and they would perform a series of interactions and then leave without any of the roles in the calling scope communicating with them. This means that any information transferred during such a protocol cannot reach any of the participants in the calling scope, so the information from the exchanges in such a protocol is essentially lost. With the restriction in place, it would always be possible for a role which participated in a protocol call to transmit relevant information to other participants through further interactions with them.
    \end{itemize}
    
    \item \textbf{Parsing} - Extending Scribble parser
    Existing parser provided a wide array of options (although not all of them were implemented). (\textbf{TODO}: More detail about designing Scribble syntax for nested protocols).
    
    Scribble module design:
    \begin{itemize}
        \item module declaration
        \item type declarations
        \item nested protocol declarations - allow top-level nested protocol declarations to be able to define protocols which are in scope for all other nested/global protocols. They were grouped at together at the beginning of the file, as it simplified parsing.
        \item global protocol declarations
    \end{itemize}
    
    Scribble global type allows nested protocol definitions inside global and nested protocols.
    
    The naive implementation of the file structure defined above resulted in shift-reduce conflicts in the parser.
    Originally nested protocol definitions simply had "nested protocol" keywords in their header instead of "global protocol". However, in the parser, protocol definitions in the parser could also optionally have protocol options before the protocol header (eg. \textbf{aux explicit} global protocol X(...) \{...\}). Because the aim was to preserve as much of the existing syntax intact, the protocol options were also added to nested protocol declarations. This was a problem, as the parser could not distinguish the boundary between nested and global protocol declarations at the top level if the declarations included the protocol options. In order to overcome this issue three approaches were considered:
    \begin{itemize}
        \item Drop the protocol options in nested protocol declarations altogether - protocol options were not implemented yet for global protocols, and they were not necessary for the initial imp implementation of nested protocols. 
        \item Move the nested keyword before the protocol options in the declaration, thereby disambiguating between both kinds of declarations. 
        \item Add an explicit delimiter (\textbf{TODO: Decide on delimiter here}) between the nested and global protocol declarations at the top level.
    \end{itemize}
    
    AST for nested protocols was the same as as for global protocols, which meant that a lot of the exisiting implementation could be mimicked or used.
    
    \item \textbf{Protocol validation}
    
    Existing Scribble implementation allows defining multiple protocols in one module, when generating code the interactions of protocol which is being implemented will be expanded in order to remove all calls to other protocols. However in nested protocols, in order to mainitain a more modularized approach, interactions within a protocol are self-contained and implemented as a separate sub-session. This means that this process of expanding of the interactions was not needed. All that was required was to verify that all calls to nested/global protocols across all protcols were valid. This involved checking that:
    \begin{itemize}
        \item A call to a nested protocol
        
    \end{itemize}
    \textbf{TODO: Check for unused roles}
    \textbf{TODO: Mutually recursive protocol cycles}
    
    \item \textbf{Projection}
    Checking consistent choice: Any of the roles involved in a call are viable candidates to be the first receiver of the choice.

    blajodfhlkasjhfkajsdbflaksjdb
    fdsakjfhalsdk 
    \textbf{TODO: Verify - technically, the first message will always be for the role who will be the first participant in the protocol. Is it fine to consider all of them as a single unit, or should it just be the first one?}
\end{itemize}{}

%% bibliography
\bibliographystyle{acm}
% \nocite{*}
\bibliography{interimbib}

\end{document}